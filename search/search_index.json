{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocstrings \u00b6 Automatic documentation from sources, for mkdocs. Features Python handler features Requirements Installation Usage Features \u00b6 Language agnostic: just like mkdocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it for any language, as long as you implement a handler for it. Currently, we only have a Python handler . Maybe you'd like to contribute another one ? Multiple themes support: each handler can offer multiple themes. Currently, we only offer the Material theme for the Python handler. Cross-references to other objects: mkdocstrings makes it possible to reference other headings from your Markdown files with the classic Markdown syntax: [identifier][] or [title][identifier] . This feature is language agnostic as well: you can cross-reference any heading that appear in your Markdown pages. If the handler for a particular language renders headings for documented objects, you'll be able to reference them! Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by mkdocs when serving the documentation, for auto-reload. Sane defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs. Python handler features \u00b6 Data collection from source code : collection of the object-tree and the docstrings is done by pytkdocs . The following features are possible thanks to it: Support for type annotations: pytkdocs collects your type annotations and mkdocstrings uses them to display parameters types or return types. Recursive documentation of Python objects: just use the module dotted-path as identifier, and you get the full module docs. You don't need to inject documentation for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by pytkdocs in modules, classes and even in __init__ methods. Support for objects properties: pytkdocs detects if a method is a staticmethod , a classmethod , etc., it also detects if a property is read-only or writable, and more! These properties will be displayed next to the object signature by mkdocstrings . Google-style sections support in docstrings: pytkdocs understands Arguments: , Raises: and Returns: sections, and returns structured data for mkdocstrings to render them. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Every object has a TOC entry: we render a heading for each object, meaning mkdocs picks them into the Table of Contents, which is nicely display by the Material theme. Thanks to mkdocstrings cross-reference ability, you can even reference other objects within your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] Source code display: mkdocstrings can add a collapsible div containing the highlighted source code of the Python object. To get an example of what is possible, check mkdocstrings ' own documentation , auto-generated from sources by itself of course, and the following GIF: Roadmap \u00b6 [x] January-March 2020: Big refactor. [ ] March-April 2020: Write. Tests. Because. It's important. Gather feedback about Python handler configuration options. Work the backlog. Requirements \u00b6 mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 Note This project currently only works with the Material theme of MkDocs. Therefore, it is required that you have it installed. pip install mkdocs-material Installation \u00b6 With pip : python3.6 -m pip install mkdocstrings Usage \u00b6 # mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings : default_handler : python handlers : python : rendering : show_source : true watch : - src/my_library In one of your markdown files: # Reference :: : my_library.my_module.my_class rendering : show_source : false :: : org.jpackage.BestOfTheBestFactoryInterface handler : java # we don't have a java handler yet, it's just an example In documentation strings (written in Markdown), you can reference objects from other places: def some_function (): \"\"\" This is my function. It references [another function][package.submodule.function]. It also references another object directly: [package.submodule.SuperClass][]. \"\"\" pass Add some style in docs/custom.css : div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } And add it to your mkdocs.yml : extra_css : - custom.css","title":"Overview"},{"location":"#mkdocstrings","text":"Automatic documentation from sources, for mkdocs. Features Python handler features Requirements Installation Usage","title":"mkdocstrings"},{"location":"#features","text":"Language agnostic: just like mkdocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it for any language, as long as you implement a handler for it. Currently, we only have a Python handler . Maybe you'd like to contribute another one ? Multiple themes support: each handler can offer multiple themes. Currently, we only offer the Material theme for the Python handler. Cross-references to other objects: mkdocstrings makes it possible to reference other headings from your Markdown files with the classic Markdown syntax: [identifier][] or [title][identifier] . This feature is language agnostic as well: you can cross-reference any heading that appear in your Markdown pages. If the handler for a particular language renders headings for documented objects, you'll be able to reference them! Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by mkdocs when serving the documentation, for auto-reload. Sane defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs.","title":"Features"},{"location":"#python-handler-features","text":"Data collection from source code : collection of the object-tree and the docstrings is done by pytkdocs . The following features are possible thanks to it: Support for type annotations: pytkdocs collects your type annotations and mkdocstrings uses them to display parameters types or return types. Recursive documentation of Python objects: just use the module dotted-path as identifier, and you get the full module docs. You don't need to inject documentation for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by pytkdocs in modules, classes and even in __init__ methods. Support for objects properties: pytkdocs detects if a method is a staticmethod , a classmethod , etc., it also detects if a property is read-only or writable, and more! These properties will be displayed next to the object signature by mkdocstrings . Google-style sections support in docstrings: pytkdocs understands Arguments: , Raises: and Returns: sections, and returns structured data for mkdocstrings to render them. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Every object has a TOC entry: we render a heading for each object, meaning mkdocs picks them into the Table of Contents, which is nicely display by the Material theme. Thanks to mkdocstrings cross-reference ability, you can even reference other objects within your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] Source code display: mkdocstrings can add a collapsible div containing the highlighted source code of the Python object. To get an example of what is possible, check mkdocstrings ' own documentation , auto-generated from sources by itself of course, and the following GIF:","title":"Python handler features"},{"location":"#roadmap","text":"[x] January-March 2020: Big refactor. [ ] March-April 2020: Write. Tests. Because. It's important. Gather feedback about Python handler configuration options. Work the backlog.","title":"Roadmap"},{"location":"#requirements","text":"mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 Note This project currently only works with the Material theme of MkDocs. Therefore, it is required that you have it installed. pip install mkdocs-material","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install mkdocstrings","title":"Installation"},{"location":"#usage","text":"# mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings : default_handler : python handlers : python : rendering : show_source : true watch : - src/my_library In one of your markdown files: # Reference :: : my_library.my_module.my_class rendering : show_source : false :: : org.jpackage.BestOfTheBestFactoryInterface handler : java # we don't have a java handler yet, it's just an example In documentation strings (written in Markdown), you can reference objects from other places: def some_function (): \"\"\" This is my function. It references [another function][package.submodule.function]. It also references another object directly: [package.submodule.SuperClass][]. \"\"\" pass Add some style in docs/custom.css : div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } And add it to your mkdocs.yml : extra_css : - custom.css","title":"Usage"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . v0.10.1 - 2020-04-03 \u00b6 Compare with v0.10.0 Bug Fixes \u00b6 Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68 v0.10.0 - 2020-03-27 \u00b6 Compare with v0.9.1 Features \u00b6 Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector . v0.9.1 - 2020-03-21 \u00b6 Compare with v0.9.0 Bug fixes \u00b6 Fix cross-references when deploying to GitHub pages ( 36f804b ). v0.9.0 - 2020-03-21 \u00b6 Compare with v0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users. Features \u00b6 Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting. Bug fixes \u00b6 Various fixes and better error handling. v0.8.0 - 2020-03-04 \u00b6 Compare with v0.7.2 Breaking Changes \u00b6 Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2. v0.7.2 - 2020-03-04 \u00b6 Compare with v0.7.1 Bug Fixes \u00b6 Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ). v0.7.1 - 2020-02-18 \u00b6 Compare with v0.7.0 Bug Fixes \u00b6 Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ). v0.7.0 - 2020-01-13 \u00b6 Compare with v0.6.1 Bug Fixes \u00b6 Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ). Code Refactoring \u00b6 Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ). Features \u00b6 Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ). v0.6.1 - 2020-01-02 \u00b6 Compare with v0.6.0 Bug Fixes \u00b6 Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ). Code Refactoring \u00b6 Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ). v0.6.0 - 2019-12-28 \u00b6 Compare with v0.5.0 Bug Fixes \u00b6 Fix GenericMeta import error on Python 3.7+ ( febf2b9 ). Code Refactoring \u00b6 More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ). v0.5.0 - 2019-12-22 \u00b6 Compare with v0.4.0 Features \u00b6 Use divs in HTML contents to ease styling ( 2a36a0e ). v0.4.0 - 2019-12-22 \u00b6 Compare with v0.3.0 Features \u00b6 Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ). v0.3.0 - 2019-12-21 \u00b6 Compare with v0.2.0 Features \u00b6 Allow object referencing in docstrings ( 2dd50c0 ). v0.2.0 - 2019-12-15 \u00b6 Compare with v0.1.0 Misc \u00b6 Refactor, features, etc. ( 111fa85 ). v0.1.0 - 2019-12-12 \u00b6 Compare with first commit Misc \u00b6 Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#v0101-2020-04-03","text":"Compare with v0.10.0","title":"v0.10.1 - 2020-04-03"},{"location":"changelog/#bug-fixes","text":"Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68","title":"Bug Fixes"},{"location":"changelog/#v0100-2020-03-27","text":"Compare with v0.9.1","title":"v0.10.0 - 2020-03-27"},{"location":"changelog/#features","text":"Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector .","title":"Features"},{"location":"changelog/#v091-2020-03-21","text":"Compare with v0.9.0","title":"v0.9.1 - 2020-03-21"},{"location":"changelog/#bug-fixes_1","text":"Fix cross-references when deploying to GitHub pages ( 36f804b ).","title":"Bug fixes"},{"location":"changelog/#v090-2020-03-21","text":"Compare with v0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users.","title":"v0.9.0 - 2020-03-21"},{"location":"changelog/#features_1","text":"Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting.","title":"Features"},{"location":"changelog/#bug-fixes_2","text":"Various fixes and better error handling.","title":"Bug fixes"},{"location":"changelog/#v080-2020-03-04","text":"Compare with v0.7.2","title":"v0.8.0 - 2020-03-04"},{"location":"changelog/#breaking-changes","text":"Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2.","title":"Breaking Changes"},{"location":"changelog/#v072-2020-03-04","text":"Compare with v0.7.1","title":"v0.7.2 - 2020-03-04"},{"location":"changelog/#bug-fixes_3","text":"Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ).","title":"Bug Fixes"},{"location":"changelog/#v071-2020-02-18","text":"Compare with v0.7.0","title":"v0.7.1 - 2020-02-18"},{"location":"changelog/#bug-fixes_4","text":"Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ).","title":"Bug Fixes"},{"location":"changelog/#v070-2020-01-13","text":"Compare with v0.6.1","title":"v0.7.0 - 2020-01-13"},{"location":"changelog/#bug-fixes_5","text":"Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ).","title":"Code Refactoring"},{"location":"changelog/#features_2","text":"Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ).","title":"Features"},{"location":"changelog/#v061-2020-01-02","text":"Compare with v0.6.0","title":"v0.6.1 - 2020-01-02"},{"location":"changelog/#bug-fixes_6","text":"Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_1","text":"Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ).","title":"Code Refactoring"},{"location":"changelog/#v060-2019-12-28","text":"Compare with v0.5.0","title":"v0.6.0 - 2019-12-28"},{"location":"changelog/#bug-fixes_7","text":"Fix GenericMeta import error on Python 3.7+ ( febf2b9 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_2","text":"More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ).","title":"Code Refactoring"},{"location":"changelog/#v050-2019-12-22","text":"Compare with v0.4.0","title":"v0.5.0 - 2019-12-22"},{"location":"changelog/#features_3","text":"Use divs in HTML contents to ease styling ( 2a36a0e ).","title":"Features"},{"location":"changelog/#v040-2019-12-22","text":"Compare with v0.3.0","title":"v0.4.0 - 2019-12-22"},{"location":"changelog/#features_4","text":"Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ).","title":"Features"},{"location":"changelog/#v030-2019-12-21","text":"Compare with v0.2.0","title":"v0.3.0 - 2019-12-21"},{"location":"changelog/#features_5","text":"Allow object referencing in docstrings ( 2dd50c0 ).","title":"Features"},{"location":"changelog/#v020-2019-12-15","text":"Compare with v0.1.0","title":"v0.2.0 - 2019-12-15"},{"location":"changelog/#misc","text":"Refactor, features, etc. ( 111fa85 ).","title":"Misc"},{"location":"changelog/#v010-2019-12-12","text":"Compare with first commit","title":"v0.1.0 - 2019-12-12"},{"location":"changelog/#misc_1","text":"Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Misc"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. For bug reports, feature requests, and feedback, simply create a new issue . Try to be as descriptive as possible. Bug fixes, new features and documentation \u00b6 This project is developed using poetry . Follow the recommended installation method: curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Then follow these instructions: Fork the repository on github.com ; Clone it on your machine; Go into the directory, and run poetry install to setup the development environment; Create a new branch with git checkout -b bug-fix-or-feature-name ; Code! Write tests. Run them all. The commands to run the tests are: poetry run pytest # to run all tests sequentially poetry run pytest -v # to print one test per line poetry run pytest -n 4 # to run tests in parallel (4 workers) poetry run pytest tests/test_api.py # to run tests in a specific file pytest provides the -k option to select tests based on their names: poetry run pytest -k \"api and remove\" poetry run pytest -k \"utils or stats\" See the documentation for the -k option for more examples. A Makefile is available for convenience: make test . When the tests pass, commit (make sure to have atomic commits and contextual commit messages! Check out this awesome blog post by Chris Beams for more information. ) Push; ...and finally, create a new pull/merge request ! Make sure to follow the guidelines.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. For bug reports, feature requests, and feedback, simply create a new issue . Try to be as descriptive as possible.","title":"Contributing"},{"location":"contributing/#bug-fixes-new-features-and-documentation","text":"This project is developed using poetry . Follow the recommended installation method: curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Then follow these instructions: Fork the repository on github.com ; Clone it on your machine; Go into the directory, and run poetry install to setup the development environment; Create a new branch with git checkout -b bug-fix-or-feature-name ; Code! Write tests. Run them all. The commands to run the tests are: poetry run pytest # to run all tests sequentially poetry run pytest -v # to print one test per line poetry run pytest -n 4 # to run tests in parallel (4 workers) poetry run pytest tests/test_api.py # to run tests in a specific file pytest provides the -k option to select tests based on their names: poetry run pytest -k \"api and remove\" poetry run pytest -k \"utils or stats\" See the documentation for the -k option for more examples. A Makefile is available for convenience: make test . When the tests pass, commit (make sure to have atomic commits and contextual commit messages! Check out this awesome blog post by Chris Beams for more information. ) Push; ...and finally, create a new pull/merge request ! Make sure to follow the guidelines.","title":"Bug fixes, new features and documentation"},{"location":"credits/","text":"Credits \u00b6 These projects were used to build mkdocstrings . Thank you! python | poetry | cookie-poetry Direct dependencies \u00b6 bandit | black | coverage | flake8 | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | pylint | pytest | pytest-cov | pytest-sugar | pytest-xdist | safety | toml Indirect dependencies \u00b6 apipkg | appdirs | appnope | astroid | atomicwrites | attrs | backcall | certifi | chardet | Click | colorama | decorator | dparse | entrypoints | execnet | gitdb2 | GitPython | htmlmin | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | jsmin | lazy-object-proxy | livereload | Markdown | MarkupSafe | mccabe | mkdocs-minify-plugin | more-itertools | packaging | parso | pathspec | pbr | pep562 | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | requests | six | smmap2 | stevedore | termcolor | tornado | traitlets | typed-ast | urllib3 | wcwidth | wrapt | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build mkdocstrings . Thank you! python | poetry | cookie-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"bandit | black | coverage | flake8 | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | pylint | pytest | pytest-cov | pytest-sugar | pytest-xdist | safety | toml","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"apipkg | appdirs | appnope | astroid | atomicwrites | attrs | backcall | certifi | chardet | Click | colorama | decorator | dparse | entrypoints | execnet | gitdb2 | GitPython | htmlmin | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | jsmin | lazy-object-proxy | livereload | Markdown | MarkupSafe | mccabe | mkdocs-minify-plugin | more-itertools | packaging | parso | pathspec | pbr | pep562 | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | requests | six | smmap2 | stevedore | termcolor | tornado | traitlets | typed-ast | urllib3 | wcwidth | wrapt | zipp More credits from the author","title":"Indirect dependencies"},{"location":"troubleshooting/","text":"Troubleshooting \u00b6 The generated documentation does not look good \u00b6 Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts. Some objects are not rendered (they do not appear in the generated docs) \u00b6 Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the docstring format page. Check the output of the mkdocs command, and re-run it with -v if necessary. Warnings should appear, showing errors that happened during collection. Nothing is rendered at all \u00b6 Python? \"No\": we only support Python right now. \"Yes\": is your package available in the Python path? If not, install it in your current virtualenv and try again. Make sure you don't have an old version of your package installed, shadowing your source code. Mkdocs warns me about links to unfound documentation files \u00b6 A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] . WindowsPath object is not iterable \u00b6 If you get a traceback like this one: ... File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\python.py\", line 244, in get_handler return PythonHandler(collector=PythonCollector(), renderer=PythonRenderer(\"python\", theme)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\__init__.py\", line 124, in __init__ self.env = Environment(autoescape=True, loader=FileSystemLoader(theme_dir)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\jinja2\\loaders.py\", line 163, in __init__ self.searchpath = list(searchpath) TypeError: 'WindowsPath' object is not iterable Try upgrading your installed version of Jinja2: pip install -U jinja2 Version 2.11.1 seems to be working fine. Python specifics \u00b6 My docstrings in comments ( #: ) are not picked up \u00b6 It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. Write: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\" It does not look better, I know, but this is the price to pay. LaTeX in docstrings is not rendered correctly \u00b6 If you are using a Markdown extension like markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\" Code blocks in admonitions (in docstrings or else) are not rendered correctly \u00b6 To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences My wrapped function shows documentation/code for its wrapper instead of its own \u00b6 Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#the-generated-documentation-does-not-look-good","text":"Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts.","title":"The generated documentation does not look good"},{"location":"troubleshooting/#some-objects-are-not-rendered-they-do-not-appear-in-the-generated-docs","text":"Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the docstring format page. Check the output of the mkdocs command, and re-run it with -v if necessary. Warnings should appear, showing errors that happened during collection.","title":"Some objects are not rendered (they do not appear in the generated docs)"},{"location":"troubleshooting/#nothing-is-rendered-at-all","text":"Python? \"No\": we only support Python right now. \"Yes\": is your package available in the Python path? If not, install it in your current virtualenv and try again. Make sure you don't have an old version of your package installed, shadowing your source code.","title":"Nothing is rendered at all"},{"location":"troubleshooting/#mkdocs-warns-me-about-links-to-unfound-documentation-files","text":"A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] .","title":"Mkdocs warns me about links to unfound documentation files"},{"location":"troubleshooting/#windowspath-object-is-not-iterable","text":"If you get a traceback like this one: ... File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\python.py\", line 244, in get_handler return PythonHandler(collector=PythonCollector(), renderer=PythonRenderer(\"python\", theme)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\__init__.py\", line 124, in __init__ self.env = Environment(autoescape=True, loader=FileSystemLoader(theme_dir)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\jinja2\\loaders.py\", line 163, in __init__ self.searchpath = list(searchpath) TypeError: 'WindowsPath' object is not iterable Try upgrading your installed version of Jinja2: pip install -U jinja2 Version 2.11.1 seems to be working fine.","title":"WindowsPath object is not iterable"},{"location":"troubleshooting/#python-specifics","text":"","title":"Python specifics"},{"location":"troubleshooting/#my-docstrings-in-comments-are-not-picked-up","text":"It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. Write: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\" It does not look better, I know, but this is the price to pay.","title":"My docstrings in comments (#:) are not picked up"},{"location":"troubleshooting/#latex-in-docstrings-is-not-rendered-correctly","text":"If you are using a Markdown extension like markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\"","title":"LaTeX in docstrings is not rendered correctly"},{"location":"troubleshooting/#code-blocks-in-admonitions-in-docstrings-or-else-are-not-rendered-correctly","text":"To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences","title":"Code blocks in admonitions (in docstrings or else) are not rendered correctly"},{"location":"troubleshooting/#my-wrapped-function-shows-documentationcode-for-its-wrapper-instead-of-its-own","text":"Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"My wrapped function shows documentation/code for its wrapper instead of its own"},{"location":"handlers/overview/","text":"Handlers \u00b6 A handler is what makes it possible to collect and render documentation for a particular language. It is composed of a collector and a renderer. See the documentation for [ BaseHandler ][mkdocstrings.handlers.BaseHandler], [ BaseCollector ][mkdocstrings.handlers.BaseCollector] and [ BaseRenderer ][mkdocstrings.handlers.BaseRenderer]. Available handlers \u00b6 [Python][mkdocstrings.handlers.python]","title":"Overview"},{"location":"handlers/overview/#handlers","text":"A handler is what makes it possible to collect and render documentation for a particular language. It is composed of a collector and a renderer. See the documentation for [ BaseHandler ][mkdocstrings.handlers.BaseHandler], [ BaseCollector ][mkdocstrings.handlers.BaseCollector] and [ BaseRenderer ][mkdocstrings.handlers.BaseRenderer].","title":"Handlers"},{"location":"handlers/overview/#available-handlers","text":"[Python][mkdocstrings.handlers.python]","title":"Available handlers"},{"location":"handlers/python/","text":"Documentation collection \u00b6 This page is a work in progress. Docstrings format \u00b6 Your docstrings must follow a particular format, otherwise mkdocstrings will throw an exception. This will be improved to be more robust over time. from typing import Optional def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\" A short description of this function. A longer description of this function. You can use more lines. This is a code block, as usual. ```python s = \"This is a Python code block :)\" ``` Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines with at least two more spaces. They will all be concatenated in one line, so do not try to use complex markup here. Note: We omitted the type hints next to the parameters names. Usually you would write something like `param1 (int): ...`, but `mkdocstrings` gets the type information from the signature, so it's not needed here. Exceptions are written the same. Raises: OSError: Explain when this error is thrown. RuntimeError: Explain as well. Multi-line description, etc. Let's see the return value section now. Returns: A description of the value that is returned. Again multiple lines are allowed. They will also be concatenated to one line, so do not use complex markup here. Note: Other words are supported: - `Args`, `Arguments`, `Params` and `Parameters` for the parameters. - `Raise`, `Raises`, `Except`, and `Exceptions` for exceptions. - `Return` or `Returns` for return value. They are all case-insensitive, so you can write `RETURNS:` or `params:`. \"\"\" return f \" { param2 }{ param1 } \" Recommended style \u00b6 /* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } /* Don't capitalize names. */ h5 . doc-heading { text-transform : none !important ; } /* Don't use vertical space on hidden ToC entries. */ h6 . hidden-toc { margin : 0 !important ; position : relative ; top : -70 px ; } h6 . hidden-toc :: before { margin-top : 0 !important ; padding-top : 0 !important ; } /* Don't show permalink of hidden ToC entries. */ h6 . hidden-toc a . headerlink { display : none ; } /* Avoid breaking parameters name, etc. in table cells. */ td code { word-break : normal !important ; } /* For pieces of Markdown rendered in table cells. */ td p { margin-top : 0 !important ; margin-bottom : 0 !important ; }","title":"Python"},{"location":"handlers/python/#documentation-collection","text":"This page is a work in progress.","title":"Documentation collection"},{"location":"handlers/python/#docstrings-format","text":"Your docstrings must follow a particular format, otherwise mkdocstrings will throw an exception. This will be improved to be more robust over time. from typing import Optional def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\" A short description of this function. A longer description of this function. You can use more lines. This is a code block, as usual. ```python s = \"This is a Python code block :)\" ``` Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines with at least two more spaces. They will all be concatenated in one line, so do not try to use complex markup here. Note: We omitted the type hints next to the parameters names. Usually you would write something like `param1 (int): ...`, but `mkdocstrings` gets the type information from the signature, so it's not needed here. Exceptions are written the same. Raises: OSError: Explain when this error is thrown. RuntimeError: Explain as well. Multi-line description, etc. Let's see the return value section now. Returns: A description of the value that is returned. Again multiple lines are allowed. They will also be concatenated to one line, so do not use complex markup here. Note: Other words are supported: - `Args`, `Arguments`, `Params` and `Parameters` for the parameters. - `Raise`, `Raises`, `Except`, and `Exceptions` for exceptions. - `Return` or `Returns` for return value. They are all case-insensitive, so you can write `RETURNS:` or `params:`. \"\"\" return f \" { param2 }{ param1 } \"","title":"Docstrings format"},{"location":"handlers/python/#recommended-style","text":"/* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } /* Don't capitalize names. */ h5 . doc-heading { text-transform : none !important ; } /* Don't use vertical space on hidden ToC entries. */ h6 . hidden-toc { margin : 0 !important ; position : relative ; top : -70 px ; } h6 . hidden-toc :: before { margin-top : 0 !important ; padding-top : 0 !important ; } /* Don't show permalink of hidden ToC entries. */ h6 . hidden-toc a . headerlink { display : none ; } /* Avoid breaking parameters name, etc. in table cells. */ td code { word-break : normal !important ; } /* For pieces of Markdown rendered in table cells. */ td p { margin-top : 0 !important ; margin-bottom : 0 !important ; }","title":"Recommended style"},{"location":"reference/extension/","text":"\u00b6 This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a [handler][mkdocstrings.handlers.BaseHandler] to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc AutoDocProcessor \u00b6 Our \"autodoc\" Markdown block processor. It has a [ test method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [ run method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. __init__ ( self , parser , md , config ) special \u00b6 Initialization method. Parameters: Name Type Description Default parser required md Markdown A markdown.Markdown instance. required config dict The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the mkdocstrings plugin. required Source code in mkdocstrings/extension.py 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , parser , md : Markdown , config : dict ) -> None : \"\"\" Initialization method. Arguments: parser: md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config get_handler_config ( self , handler_name ) \u00b6 Return the global configuration of the given handler. Parameters: Name Type Description Default handler_name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in mkdocstrings/extension.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def get_handler_config ( self , handler_name : str ) -> dict : \"\"\" Return the global configuration of the given handler. Arguments: handler_name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( handler_name , {}) return {} get_handler_name ( self , config ) \u00b6 Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in mkdocstrings/extension.py 166 167 168 169 170 171 172 173 174 175 176 177 178 def get_handler_name ( self , config : dict ) -> str : \"\"\" Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Args: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" if \"handler\" in config : return config [ \"handler\" ] return self . _config [ \"mkdocstrings\" ][ \"default_handler\" ] get_item_configs ( self , handler_name , config ) \u00b6 Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_name str The handler to get the global configuration of. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple[dict, dict] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def get_item_configs ( self , handler_name : str , config : dict ) -> Tuple [ dict , dict ]: \"\"\" Get the selection and rendering configuration merged into the global configuration of the given handler. Args: handler_name: The handler to get the global configuration of. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" handler_config = self . get_handler_config ( handler_name ) item_selection_config = dict ( handler_config . get ( \"selection\" , {})) item_selection_config . update ( config . get ( \"selection\" , {})) item_rendering_config = dict ( handler_config . get ( \"rendering\" , {})) item_rendering_config . update ( config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config run ( self , parent , blocks ) \u00b6 Run processor. Must be overridden by subclasses. When the parser determines the appropriate type of a block, the parser will call the corresponding processor's run method. This method should parse the individual lines of the block and append them to the etree. Note that both the parent and etree keywords are pointers to instances of the objects which should be edited in place. Each processor must make changes to the existing objects as there is no mechanism to return new/different objects to replace them. This means that this method should be adding SubElements or adding text to the parent, and should remove ( pop ) or add ( insert ) items to the list of blocks. Keywords: parent : A etree element which is the parent of the current block. blocks : A list of all remaining blocks of the document. Source code in mkdocstrings/extension.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def run ( self , parent : Element , blocks : Element ) -> None : block = blocks . pop ( 0 ) m = self . RE . search ( str ( block )) if m : # removes the first line block = block [ m . end () :] # type: ignore block , the_rest = self . detab ( block ) if m : identifier = m . group ( 1 ) log . debug ( f \"mkdocstrings.extension: Matched '::: { identifier } '\" ) config = yaml . safe_load ( str ( block )) or {} handler_name = self . get_handler_name ( config ) log . debug ( f \"mkdocstrings.extension: Using handler ' { handler_name } '\" ) handler = get_handler ( handler_name , self . _config [ \"theme_name\" ]) selection , rendering = self . get_item_configs ( handler_name , config ) log . debug ( \"mkdocstrings.extension: Collecting data\" ) try : data = handler . collector . collect ( identifier , selection ) except CollectionError : log . error ( f \"mkdocstrings.extension: Could not collect ' { identifier } '\" ) return log . debug ( \"mkdocstrings.extension: Updating renderer's env\" ) handler . renderer . update_env ( self . md , self . _config ) log . debug ( \"mkdocstrings.extension: Rendering templates\" ) rendered = handler . renderer . render ( data , rendering ) log . debug ( \"mkdocstrings.extension: Loading HTML back into XML tree\" ) try : as_xml = XML ( rendered ) except ParseError as error : message = f \"mkdocstrings.extension: { error } \" if \"mismatched tag\" in str ( error ): line , column = str ( error ) . split ( \":\" )[ - 1 ] . split ( \", \" ) lineno = int ( line . split ( \" \" )[ - 1 ]) columnno = int ( column . split ( \" \" )[ - 1 ]) line = rendered . split ( \" \\n \" )[ lineno - 1 ] character = line [ columnno ] message += ( f \" (character { character } ): \\n { line } \\n \" f \"If your Markdown contains angle brackets < >, try to wrap them between backticks `< >`, \" f \"or replace them with < and >\" ) log . error ( message ) return as_xml = atomic_brute_cast ( as_xml ) # type: ignore parent . append ( as_xml ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) test ( self , parent , block ) \u00b6 Test for block type. Must be overridden by subclasses. As the parser loops through processors, it will call the test method on each to determine if the given block of text is of that type. This method must return a boolean True or False . The actual method of testing is left to the needs of that particular block type. It could be as simple as block.startswith(some_string) or a complex regular expression. As the block type may be different depending on the parent of the block (i.e. inside a list), the parent etree element is also provided and may be used as part of the test. Keywords: parent : A etree element which will be the parent of the block. block : A block of text from the source which has been split at blank lines. Source code in mkdocstrings/extension.py 92 93 94 95 96 97 98 99 100 def test ( self , parent : Element , block : Element ) -> bool : sibling = self . lastChild ( parent ) bool1 = self . RE . search ( str ( block )) bool2 = ( str ( block ) . startswith ( \" \" * self . tab_length ) and sibling is not None and sibling . get ( \"class\" , \"\" ) . find ( self . CLASSNAME ) != - 1 ) return bool ( bool1 or bool2 ) MkdocstringsExtension \u00b6 Our Markdown extension. It cannot work outside of mkdocstrings . __init__ ( self , config , ** kwargs ) special \u00b6 Initialization method. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in [ extendMarkdown ][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. required kwargs Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py 221 222 223 224 225 226 227 228 229 230 231 def __init__ ( self , config : dict , ** kwargs ) -> None : \"\"\" Initialization method. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config extendMarkdown ( self , md ) \u00b6 Register the extension. Add an instance of our [ AutoDocProcessor ][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py 233 234 235 236 237 238 239 240 241 242 243 244 def extendMarkdown ( self , md : Markdown ) -> None : \"\"\" Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Args: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) processor = AutoDocProcessor ( md . parser , md , self . _config ) md . parser . blockprocessors . register ( processor , \"mkdocstrings\" , 110 ) atomic_brute_cast ( tree ) \u00b6 Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue Python-Markdown/markdown#920 . On a side note: isn't atomic_brute_cast such a beautiful function name? Parameters: Name Type Description Default tree Element An XML node, used like the root of an XML tree. required Returns: Type Description Optional[xml.etree.ElementTree.Element] The same node, recursively modified by side-effect. You can skip re-assigning the return value. Source code in mkdocstrings/extension.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def atomic_brute_cast ( tree : Element ) -> Union [ Element , None ]: \"\"\" Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue [Python-Markdown/markdown#920](https://github.com/Python-Markdown/markdown/issues/920). On a side note: isn't `atomic_brute_cast` such a beautiful function name? Arguments: tree: An XML node, used like the root of an XML tree. Returns: The same node, recursively modified by side-effect. You can skip re-assigning the return value. \"\"\" if tree . text : tree . text = AtomicString ( tree . text ) for child in tree : atomic_brute_cast ( child ) return tree","title":"extension.py"},{"location":"reference/extension/#mkdocstrings.extension","text":"This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a [handler][mkdocstrings.handlers.BaseHandler] to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc","title":"mkdocstrings.extension"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor","text":"Our \"autodoc\" Markdown block processor. It has a [ test method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [ run method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block.","title":"AutoDocProcessor"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.__init__","text":"Initialization method. Parameters: Name Type Description Default parser required md Markdown A markdown.Markdown instance. required config dict The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the mkdocstrings plugin. required Source code in mkdocstrings/extension.py 78 79 80 81 82 83 84 85 86 87 88 89 90 def __init__ ( self , parser , md : Markdown , config : dict ) -> None : \"\"\" Initialization method. Arguments: parser: md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.get_handler_config","text":"Return the global configuration of the given handler. Parameters: Name Type Description Default handler_name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in mkdocstrings/extension.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def get_handler_config ( self , handler_name : str ) -> dict : \"\"\" Return the global configuration of the given handler. Arguments: handler_name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( handler_name , {}) return {}","title":"get_handler_config()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.get_handler_name","text":"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in mkdocstrings/extension.py 166 167 168 169 170 171 172 173 174 175 176 177 178 def get_handler_name ( self , config : dict ) -> str : \"\"\" Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Args: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" if \"handler\" in config : return config [ \"handler\" ] return self . _config [ \"mkdocstrings\" ][ \"default_handler\" ]","title":"get_handler_name()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.get_item_configs","text":"Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_name str The handler to get the global configuration of. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple[dict, dict] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 def get_item_configs ( self , handler_name : str , config : dict ) -> Tuple [ dict , dict ]: \"\"\" Get the selection and rendering configuration merged into the global configuration of the given handler. Args: handler_name: The handler to get the global configuration of. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" handler_config = self . get_handler_config ( handler_name ) item_selection_config = dict ( handler_config . get ( \"selection\" , {})) item_selection_config . update ( config . get ( \"selection\" , {})) item_rendering_config = dict ( handler_config . get ( \"rendering\" , {})) item_rendering_config . update ( config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config","title":"get_item_configs()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.run","text":"Run processor. Must be overridden by subclasses. When the parser determines the appropriate type of a block, the parser will call the corresponding processor's run method. This method should parse the individual lines of the block and append them to the etree. Note that both the parent and etree keywords are pointers to instances of the objects which should be edited in place. Each processor must make changes to the existing objects as there is no mechanism to return new/different objects to replace them. This means that this method should be adding SubElements or adding text to the parent, and should remove ( pop ) or add ( insert ) items to the list of blocks. Keywords: parent : A etree element which is the parent of the current block. blocks : A list of all remaining blocks of the document. Source code in mkdocstrings/extension.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def run ( self , parent : Element , blocks : Element ) -> None : block = blocks . pop ( 0 ) m = self . RE . search ( str ( block )) if m : # removes the first line block = block [ m . end () :] # type: ignore block , the_rest = self . detab ( block ) if m : identifier = m . group ( 1 ) log . debug ( f \"mkdocstrings.extension: Matched '::: { identifier } '\" ) config = yaml . safe_load ( str ( block )) or {} handler_name = self . get_handler_name ( config ) log . debug ( f \"mkdocstrings.extension: Using handler ' { handler_name } '\" ) handler = get_handler ( handler_name , self . _config [ \"theme_name\" ]) selection , rendering = self . get_item_configs ( handler_name , config ) log . debug ( \"mkdocstrings.extension: Collecting data\" ) try : data = handler . collector . collect ( identifier , selection ) except CollectionError : log . error ( f \"mkdocstrings.extension: Could not collect ' { identifier } '\" ) return log . debug ( \"mkdocstrings.extension: Updating renderer's env\" ) handler . renderer . update_env ( self . md , self . _config ) log . debug ( \"mkdocstrings.extension: Rendering templates\" ) rendered = handler . renderer . render ( data , rendering ) log . debug ( \"mkdocstrings.extension: Loading HTML back into XML tree\" ) try : as_xml = XML ( rendered ) except ParseError as error : message = f \"mkdocstrings.extension: { error } \" if \"mismatched tag\" in str ( error ): line , column = str ( error ) . split ( \":\" )[ - 1 ] . split ( \", \" ) lineno = int ( line . split ( \" \" )[ - 1 ]) columnno = int ( column . split ( \" \" )[ - 1 ]) line = rendered . split ( \" \\n \" )[ lineno - 1 ] character = line [ columnno ] message += ( f \" (character { character } ): \\n { line } \\n \" f \"If your Markdown contains angle brackets < >, try to wrap them between backticks `< >`, \" f \"or replace them with < and >\" ) log . error ( message ) return as_xml = atomic_brute_cast ( as_xml ) # type: ignore parent . append ( as_xml ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest )","title":"run()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.test","text":"Test for block type. Must be overridden by subclasses. As the parser loops through processors, it will call the test method on each to determine if the given block of text is of that type. This method must return a boolean True or False . The actual method of testing is left to the needs of that particular block type. It could be as simple as block.startswith(some_string) or a complex regular expression. As the block type may be different depending on the parent of the block (i.e. inside a list), the parent etree element is also provided and may be used as part of the test. Keywords: parent : A etree element which will be the parent of the block. block : A block of text from the source which has been split at blank lines. Source code in mkdocstrings/extension.py 92 93 94 95 96 97 98 99 100 def test ( self , parent : Element , block : Element ) -> bool : sibling = self . lastChild ( parent ) bool1 = self . RE . search ( str ( block )) bool2 = ( str ( block ) . startswith ( \" \" * self . tab_length ) and sibling is not None and sibling . get ( \"class\" , \"\" ) . find ( self . CLASSNAME ) != - 1 ) return bool ( bool1 or bool2 )","title":"test()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension","text":"Our Markdown extension. It cannot work outside of mkdocstrings .","title":"MkdocstringsExtension"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.__init__","text":"Initialization method. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in [ extendMarkdown ][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. required kwargs Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py 221 222 223 224 225 226 227 228 229 230 231 def __init__ ( self , config : dict , ** kwargs ) -> None : \"\"\" Initialization method. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.extendMarkdown","text":"Register the extension. Add an instance of our [ AutoDocProcessor ][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py 233 234 235 236 237 238 239 240 241 242 243 244 def extendMarkdown ( self , md : Markdown ) -> None : \"\"\" Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Args: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) processor = AutoDocProcessor ( md . parser , md , self . _config ) md . parser . blockprocessors . register ( processor , \"mkdocstrings\" , 110 )","title":"extendMarkdown()"},{"location":"reference/extension/#mkdocstrings.extension.atomic_brute_cast","text":"Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue Python-Markdown/markdown#920 . On a side note: isn't atomic_brute_cast such a beautiful function name? Parameters: Name Type Description Default tree Element An XML node, used like the root of an XML tree. required Returns: Type Description Optional[xml.etree.ElementTree.Element] The same node, recursively modified by side-effect. You can skip re-assigning the return value. Source code in mkdocstrings/extension.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def atomic_brute_cast ( tree : Element ) -> Union [ Element , None ]: \"\"\" Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue [Python-Markdown/markdown#920](https://github.com/Python-Markdown/markdown/issues/920). On a side note: isn't `atomic_brute_cast` such a beautiful function name? Arguments: tree: An XML node, used like the root of an XML tree. Returns: The same node, recursively modified by side-effect. You can skip re-assigning the return value. \"\"\" if tree . text : tree . text = AtomicString ( tree . text ) for child in tree : atomic_brute_cast ( child ) return tree","title":"atomic_brute_cast()"},{"location":"reference/plugin/","text":"\u00b6 This module contains the mkdocs plugin. The plugin instantiates a Markdown extension ([ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension]), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_contents event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. Once the documentation is built, the on_post_build event hook is triggered and calls the [ handlers.teardown() method][mkdocstrings.handlers.teardown]. This method is used to teardown the [handlers][mkdocstrings.handlers] that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook . AUTO_REF: Pattern \u00b6 A regular expression to match unresolved Markdown references in the [ on_post_page hook][mkdocstrings.plugin.MkdocstringsPlugin.on_post_page]. RENDERING_OPTS_KEY: str \u00b6 The name of the rendering parameter in YAML configuration blocks. SELECTION_OPTS_KEY: str \u00b6 The name of the selection parameter in YAML configuration blocks. MkdocstringsPlugin \u00b6 An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_contents on_post_page on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system.. config_scheme: Tuple [ Tuple [ str , MkType ]] class-attribute \u00b6 The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" rust : selection : selection_opt : 2 fix_ref ( self , unmapped , unintended ) \u00b6 Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we append the identifier to the outer unintended list to tell the caller that this unresolved reference should be ignored as it's probably not intended as a reference. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default unmapped List[str] A list to store unmapped identifiers. required unintended List[str] A list to store identifiers of unintended references. required Returns: Type Description Callable The actual function accepting a Match object and returning the replacement strings. Source code in mkdocstrings/plugin.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def fix_ref ( self , unmapped : List [ str ], unintended : List [ str ]) -> Callable : \"\"\" Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we append the identifier to the outer `unintended` list to tell the caller that this unresolved reference should be ignored as it's probably not intended as a reference. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: unmapped: A list to store unmapped identifiers. unintended: A list to store identifiers of unintended references. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): groups = match . groupdict () identifier = groups [ \"identifier\" ] title = groups [ \"title\" ] if title and not identifier : identifier , title = title , identifier try : url = self . url_map [ identifier ] except KeyError : if \" \" in identifier or \"/\" in identifier : # invalid identifier, must not be a intended reference unintended . append ( identifier ) else : unmapped . append ( identifier ) if not title : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" # TODO: we could also use a config option to ignore some identifiers # and to map others to URLs, something like: # references: # ignore: # - \"USERNAME:PASSWORD@\" # map: # some-id: https://example.com return f '<a href=\" { url } \"> { title or identifier } </a>' return inner map_urls ( self , base_url , anchor ) \u00b6 Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocstrings/plugin.py 163 164 165 166 167 168 169 170 171 172 173 174 175 def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\" Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . url_map [ anchor . id ] = base_url + anchor . url for child in anchor . children : self . map_urls ( base_url , child ) on_config ( self , config , ** kwargs ) \u00b6 Hook for the on_config event . In this hook, we instantiate our [ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Source code in mkdocstrings/plugin.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def on_config ( self , config : Config , ** kwargs ) -> Config : \"\"\" Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). \"\"\" log . debug ( \"mkdocstrings.plugin: Adding extension to the list\" ) extension_config = dict ( theme_name = config [ \"theme\" ] . name , mdx = config [ \"markdown_extensions\" ], mdx_configs = config [ \"mdx_configs\" ], mkdocstrings = self . config , ) self . mkdocstrings_extension = MkdocstringsExtension ( config = extension_config ) config [ \"markdown_extensions\" ] . append ( self . mkdocstrings_extension ) return config on_page_content ( self , html , page , config , files , ** kwargs ) \u00b6 Hook for the on_page_contents event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Source code in mkdocstrings/plugin.py 150 151 152 153 154 155 156 157 158 159 160 161 def on_page_content ( self , html : str , page : Page , config : Config , files : Files , ** kwargs ) -> str : \"\"\" Hook for the [`on_page_contents` event](https://www.mkdocs.org/user-guide/plugins/#on_page_contents). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. \"\"\" log . debug ( f \"mkdocstrings.plugin: Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . canonical_url , item ) return html on_post_build ( self , config , ** kwargs ) \u00b6 Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [ teardown() method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Source code in mkdocstrings/plugin.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def on_post_build ( self , config : Config , ** kwargs ) -> None : \"\"\" Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [`teardown()` method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. \"\"\" log . debug ( \"mkdocstrings.plugin: Tearing handlers down\" ) teardown () on_post_page ( self , output , page , config , ** kwargs ) \u00b6 Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of mkdocstrings to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [ AUTO_REF ][mkdocstrings.plugin.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Source code in mkdocstrings/plugin.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def on_post_page ( self , output : str , page : Page , config : Config , ** kwargs ) -> str : \"\"\" Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `mkdocstrings` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF`][mkdocstrings.plugin.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. \"\"\" log . debug ( f \"mkdocstrings.plugin: Fixing references in page { page . file . src_path } \" ) placeholder = Placeholder () while re . search ( placeholder . seed , output ) or any ( placeholder . seed in url for url in self . url_map . values ()): placeholder . set_seed () unmapped , unintended = [], [] # type: ignore soup = BeautifulSoup ( output , \"html.parser\" ) placeholder . replace_code_tags ( soup ) fixed_soup = AUTO_REF . sub ( self . fix_ref ( unmapped , unintended ), str ( soup )) if unmapped or unintended : # We do nothing with unintended refs if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \"mkdocstrings.plugin: { page . file . src_path } : Could not fix ref '[ { ref } ]'. \\n \" f \"The referenced object was not both collected and rendered.\" ) return placeholder . restore_code_tags ( fixed_soup ) on_serve ( self , server , config , ** kwargs ) \u00b6 Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Note The implementation is a hack. We are retrieving the watch function from a protected attribute. See issue mkdocs/mkdocs#1952 for more information. Source code in mkdocstrings/plugin.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def on_serve ( self , server : Server , config : Config , ** kwargs ) -> Server : \"\"\" Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Note: The implementation is a hack. We are retrieving the watch function from a protected attribute. See issue [mkdocs/mkdocs#1952](https://github.com/mkdocs/mkdocs/issues/1952) for more information. \"\"\" builder = list ( server . watcher . _tasks . values ())[ 0 ][ \"func\" ] for element in self . config [ \"watch\" ]: log . debug ( f \"mkdocstrings.plugin: Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) return server Placeholder \u00b6 This class is used as a placeholder store. Placeholders are random, unique strings that temporarily replace <code> nodes in an HTML tree. Why do we replace these nodes with such strings? Because we want to fix cross-references that were not resolved during Markdown conversion, and we must never touch to what's inside of a code block. To ease the process, instead of selecting nodes in the HTML tree with complex filters (I tried, believe me), we simply \"hide\" the code nodes, and bulk-replace unresolved cross-references in the whole HTML text at once, with a regular expression substitution. Once it's done, we bulk-replace code nodes back, with a regular expression substitution again. get_id ( self ) \u00b6 Return a random, unique string. Source code in mkdocstrings/plugin.py 319 320 321 def get_id ( self ) -> str : \"\"\"Return a random, unique string.\"\"\" return f \" { self . seed }{ random . randint ( 0 , 1000000 ) } \" # nosec: it's not for security/cryptographic purposes replace_code_tags ( self , soup ) \u00b6 Recursively replace code nodes with navigable strings whose values are unique IDs. Parameters: Name Type Description Default soup str The root tag of a BeautifulSoup HTML tree. required Source code in mkdocstrings/plugin.py 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 def replace_code_tags ( self , soup : str ) -> None : \"\"\" Recursively replace code nodes with navigable strings whose values are unique IDs. Arguments: soup: The root tag of a BeautifulSoup HTML tree. \"\"\" def recursive_replace ( tag ): if hasattr ( tag , \"contents\" ): for i in range ( len ( tag . contents )): child = tag . contents [ i ] if child . name == \"code\" : tag . contents [ i ] = NavigableString ( self . store ( str ( child ))) else : recursive_replace ( child ) recursive_replace ( soup ) restore_code_tags ( self , soup_str ) \u00b6 Restore code nodes previously replaced by unique placeholders. Parameters: Name Type Description Default soup_str str HTML text. required Returns: Type Description str The same HTML text with placeholders replaced by their respective original code nodes. Source code in mkdocstrings/plugin.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def restore_code_tags ( self , soup_str : str ) -> str : \"\"\" Restore code nodes previously replaced by unique placeholders. Args: soup_str: HTML text. Returns: The same HTML text with placeholders replaced by their respective original code nodes. \"\"\" def replace_placeholder ( match ): placeholder = match . groups ()[ 0 ] return self . ids [ placeholder ] return re . sub ( rf \"( { self . seed } \\d+)\" , replace_placeholder , soup_str ) set_seed ( self ) \u00b6 Reset the seed in self.seed with a random string. Source code in mkdocstrings/plugin.py 323 324 325 def set_seed ( self ) -> None : \"\"\"Reset the seed in `self.seed` with a random string.\"\"\" self . seed = \"\" . join ( random . choices ( string . ascii_letters + string . digits , k = 16 )) store ( self , value ) \u00b6 Store a text under a unique ID, return that ID. Parameters: Name Type Description Default value str The text to store. required Returns: Type Description str The ID under which the text is stored. Source code in mkdocstrings/plugin.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def store ( self , value : str ) -> str : \"\"\" Store a text under a unique ID, return that ID. Arguments: value: The text to store. Returns: The ID under which the text is stored. \"\"\" i = self . get_id () while i in self . ids : i = self . get_id () self . ids [ i ] = value return i","title":"plugin.py"},{"location":"reference/plugin/#mkdocstrings.plugin","text":"This module contains the mkdocs plugin. The plugin instantiates a Markdown extension ([ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension]), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_contents event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. Once the documentation is built, the on_post_build event hook is triggered and calls the [ handlers.teardown() method][mkdocstrings.handlers.teardown]. This method is used to teardown the [handlers][mkdocstrings.handlers] that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook .","title":"mkdocstrings.plugin"},{"location":"reference/plugin/#mkdocstrings.plugin.AUTO_REF","text":"A regular expression to match unresolved Markdown references in the [ on_post_page hook][mkdocstrings.plugin.MkdocstringsPlugin.on_post_page].","title":"AUTO_REF"},{"location":"reference/plugin/#mkdocstrings.plugin.RENDERING_OPTS_KEY","text":"The name of the rendering parameter in YAML configuration blocks.","title":"RENDERING_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.SELECTION_OPTS_KEY","text":"The name of the selection parameter in YAML configuration blocks.","title":"SELECTION_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin","text":"An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_contents on_post_page on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system..","title":"MkdocstringsPlugin"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.config_scheme","text":"The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" rust : selection : selection_opt : 2","title":"config_scheme"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.fix_ref","text":"Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we append the identifier to the outer unintended list to tell the caller that this unresolved reference should be ignored as it's probably not intended as a reference. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default unmapped List[str] A list to store unmapped identifiers. required unintended List[str] A list to store identifiers of unintended references. required Returns: Type Description Callable The actual function accepting a Match object and returning the replacement strings. Source code in mkdocstrings/plugin.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 def fix_ref ( self , unmapped : List [ str ], unintended : List [ str ]) -> Callable : \"\"\" Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we append the identifier to the outer `unintended` list to tell the caller that this unresolved reference should be ignored as it's probably not intended as a reference. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: unmapped: A list to store unmapped identifiers. unintended: A list to store identifiers of unintended references. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): groups = match . groupdict () identifier = groups [ \"identifier\" ] title = groups [ \"title\" ] if title and not identifier : identifier , title = title , identifier try : url = self . url_map [ identifier ] except KeyError : if \" \" in identifier or \"/\" in identifier : # invalid identifier, must not be a intended reference unintended . append ( identifier ) else : unmapped . append ( identifier ) if not title : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" # TODO: we could also use a config option to ignore some identifiers # and to map others to URLs, something like: # references: # ignore: # - \"USERNAME:PASSWORD@\" # map: # some-id: https://example.com return f '<a href=\" { url } \"> { title or identifier } </a>' return inner","title":"fix_ref()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.map_urls","text":"Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocstrings/plugin.py 163 164 165 166 167 168 169 170 171 172 173 174 175 def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\" Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . url_map [ anchor . id ] = base_url + anchor . url for child in anchor . children : self . map_urls ( base_url , child )","title":"map_urls()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","text":"Hook for the on_config event . In this hook, we instantiate our [ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Source code in mkdocstrings/plugin.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def on_config ( self , config : Config , ** kwargs ) -> Config : \"\"\" Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). \"\"\" log . debug ( \"mkdocstrings.plugin: Adding extension to the list\" ) extension_config = dict ( theme_name = config [ \"theme\" ] . name , mdx = config [ \"markdown_extensions\" ], mdx_configs = config [ \"mdx_configs\" ], mkdocstrings = self . config , ) self . mkdocstrings_extension = MkdocstringsExtension ( config = extension_config ) config [ \"markdown_extensions\" ] . append ( self . mkdocstrings_extension ) return config","title":"on_config()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_page_content","text":"Hook for the on_page_contents event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Source code in mkdocstrings/plugin.py 150 151 152 153 154 155 156 157 158 159 160 161 def on_page_content ( self , html : str , page : Page , config : Config , files : Files , ** kwargs ) -> str : \"\"\" Hook for the [`on_page_contents` event](https://www.mkdocs.org/user-guide/plugins/#on_page_contents). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. \"\"\" log . debug ( f \"mkdocstrings.plugin: Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . canonical_url , item ) return html","title":"on_page_content()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_build","text":"Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [ teardown() method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Source code in mkdocstrings/plugin.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def on_post_build ( self , config : Config , ** kwargs ) -> None : \"\"\" Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [`teardown()` method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. \"\"\" log . debug ( \"mkdocstrings.plugin: Tearing handlers down\" ) teardown ()","title":"on_post_build()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_page","text":"Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of mkdocstrings to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [ AUTO_REF ][mkdocstrings.plugin.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Source code in mkdocstrings/plugin.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 def on_post_page ( self , output : str , page : Page , config : Config , ** kwargs ) -> str : \"\"\" Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `mkdocstrings` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF`][mkdocstrings.plugin.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. \"\"\" log . debug ( f \"mkdocstrings.plugin: Fixing references in page { page . file . src_path } \" ) placeholder = Placeholder () while re . search ( placeholder . seed , output ) or any ( placeholder . seed in url for url in self . url_map . values ()): placeholder . set_seed () unmapped , unintended = [], [] # type: ignore soup = BeautifulSoup ( output , \"html.parser\" ) placeholder . replace_code_tags ( soup ) fixed_soup = AUTO_REF . sub ( self . fix_ref ( unmapped , unintended ), str ( soup )) if unmapped or unintended : # We do nothing with unintended refs if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \"mkdocstrings.plugin: { page . file . src_path } : Could not fix ref '[ { ref } ]'. \\n \" f \"The referenced object was not both collected and rendered.\" ) return placeholder . restore_code_tags ( fixed_soup )","title":"on_post_page()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_serve","text":"Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Note The implementation is a hack. We are retrieving the watch function from a protected attribute. See issue mkdocs/mkdocs#1952 for more information. Source code in mkdocstrings/plugin.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def on_serve ( self , server : Server , config : Config , ** kwargs ) -> Server : \"\"\" Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Note: The implementation is a hack. We are retrieving the watch function from a protected attribute. See issue [mkdocs/mkdocs#1952](https://github.com/mkdocs/mkdocs/issues/1952) for more information. \"\"\" builder = list ( server . watcher . _tasks . values ())[ 0 ][ \"func\" ] for element in self . config [ \"watch\" ]: log . debug ( f \"mkdocstrings.plugin: Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) return server","title":"on_serve()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder","text":"This class is used as a placeholder store. Placeholders are random, unique strings that temporarily replace <code> nodes in an HTML tree. Why do we replace these nodes with such strings? Because we want to fix cross-references that were not resolved during Markdown conversion, and we must never touch to what's inside of a code block. To ease the process, instead of selecting nodes in the HTML tree with complex filters (I tried, believe me), we simply \"hide\" the code nodes, and bulk-replace unresolved cross-references in the whole HTML text at once, with a regular expression substitution. Once it's done, we bulk-replace code nodes back, with a regular expression substitution again.","title":"Placeholder"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.get_id","text":"Return a random, unique string. Source code in mkdocstrings/plugin.py 319 320 321 def get_id ( self ) -> str : \"\"\"Return a random, unique string.\"\"\" return f \" { self . seed }{ random . randint ( 0 , 1000000 ) } \" # nosec: it's not for security/cryptographic purposes","title":"get_id()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.replace_code_tags","text":"Recursively replace code nodes with navigable strings whose values are unique IDs. Parameters: Name Type Description Default soup str The root tag of a BeautifulSoup HTML tree. required Source code in mkdocstrings/plugin.py 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 def replace_code_tags ( self , soup : str ) -> None : \"\"\" Recursively replace code nodes with navigable strings whose values are unique IDs. Arguments: soup: The root tag of a BeautifulSoup HTML tree. \"\"\" def recursive_replace ( tag ): if hasattr ( tag , \"contents\" ): for i in range ( len ( tag . contents )): child = tag . contents [ i ] if child . name == \"code\" : tag . contents [ i ] = NavigableString ( self . store ( str ( child ))) else : recursive_replace ( child ) recursive_replace ( soup )","title":"replace_code_tags()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.restore_code_tags","text":"Restore code nodes previously replaced by unique placeholders. Parameters: Name Type Description Default soup_str str HTML text. required Returns: Type Description str The same HTML text with placeholders replaced by their respective original code nodes. Source code in mkdocstrings/plugin.py 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 def restore_code_tags ( self , soup_str : str ) -> str : \"\"\" Restore code nodes previously replaced by unique placeholders. Args: soup_str: HTML text. Returns: The same HTML text with placeholders replaced by their respective original code nodes. \"\"\" def replace_placeholder ( match ): placeholder = match . groups ()[ 0 ] return self . ids [ placeholder ] return re . sub ( rf \"( { self . seed } \\d+)\" , replace_placeholder , soup_str )","title":"restore_code_tags()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.set_seed","text":"Reset the seed in self.seed with a random string. Source code in mkdocstrings/plugin.py 323 324 325 def set_seed ( self ) -> None : \"\"\"Reset the seed in `self.seed` with a random string.\"\"\" self . seed = \"\" . join ( random . choices ( string . ascii_letters + string . digits , k = 16 ))","title":"set_seed()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.store","text":"Store a text under a unique ID, return that ID. Parameters: Name Type Description Default value str The text to store. required Returns: Type Description str The ID under which the text is stored. Source code in mkdocstrings/plugin.py 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 def store ( self , value : str ) -> str : \"\"\" Store a text under a unique ID, return that ID. Arguments: value: The text to store. Returns: The ID under which the text is stored. \"\"\" i = self . get_id () while i in self . ids : i = self . get_id () self . ids [ i ] = value return i","title":"store()"},{"location":"reference/handlers/__init__/","text":"\u00b6 Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache. BaseCollector \u00b6 The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method. collect ( self , identifier , config ) \u00b6 Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description Type[ForwardRef('T')] Anything you want, as long as you can feed it to the renderer's render method. Source code in mkdocstrings/handlers/__init__.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def collect ( self , identifier : str , config : dict ) -> DataType : \"\"\" Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Args: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" raise NotImplementedError teardown ( self ) \u00b6 Placeholder to remember this method can be implemented. Source code in mkdocstrings/handlers/__init__.py 189 190 def teardown ( self ) -> None : \"\"\"Placeholder to remember this method can be implemented.\"\"\" BaseHandler \u00b6 The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. __init__ ( self , collector , renderer ) special \u00b6 Initialization method. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in mkdocstrings/handlers/__init__.py 202 203 204 205 206 207 208 209 210 211 def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\" Initialization method. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer BaseRenderer \u00b6 The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a FALLBACK_THEME class-variable. __init__ ( self , directory , theme ) special \u00b6 Initialization method. If the given theme is not supported (it does not exist), it will look for a FALLBACK_THEME attribute in self to use as a fallback theme. Parameters: Name Type Description Default directory str The name of the directory containing the themes for this renderer. required theme str The name of theme to use. required Source code in mkdocstrings/handlers/__init__.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def __init__ ( self , directory : str , theme : str ) -> None : \"\"\" Initialization method. If the given theme is not supported (it does not exist), it will look for a `FALLBACK_THEME` attribute in `self` to use as a fallback theme. Arguments: directory: The name of the directory containing the themes for this renderer. theme: The name of theme to use. \"\"\" themes_dir = Path ( __file__ ) . parent . parent / \"templates\" / directory theme_dir = themes_dir / theme if not theme_dir . exists (): if self . FALLBACK_THEME != \"\" : log . warning ( f \"mkdocstrings.handlers: No ' { theme } ' theme in ' { directory } ', \" f \"falling back to theme ' { self . FALLBACK_THEME } '\" ) theme_dir = themes_dir / self . FALLBACK_THEME else : raise ThemeNotSupported ( theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( str ( theme_dir ))) self . env . filters [ \"highlight\" ] = do_highlight self . env . filters [ \"any\" ] = do_any render ( self , data , config ) \u00b6 Render a template using provided data and configuration options. Parameters: Name Type Description Default data Type[ForwardRef('T')] The collected data to render. required config dict The rendering options. required Returns: Type Description str The renderer template as HTML. Source code in mkdocstrings/handlers/__init__.py 130 131 132 133 134 135 136 137 138 139 140 141 def render ( self , data : DataType , config : dict ) -> str : \"\"\" Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The renderer template as HTML. \"\"\" raise NotImplementedError update_env ( self , md , config ) \u00b6 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/__init__.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def update_env ( self , md : Markdown , config : dict ) -> None : \"\"\" Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" md = Markdown ( extensions = config [ \"mdx\" ], extensions_configs = config [ \"mdx_configs\" ]) def convert_markdown ( text ): return do_mark_safe ( md . convert ( text )) self . env . filters [ \"convert_markdown\" ] = convert_markdown CollectionError \u00b6 An exception raised when some collection of data failed. ThemeNotSupported \u00b6 An exception raised to tell a theme is not supported. do_any ( seq , attribute = None ) \u00b6 The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in mkdocstrings/handlers/__init__.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\" The `any` builtin as a filter for Jinja templates. Args: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( o [ attribute ] for o in seq ) do_highlight ( src , guess_lang = False , language = None , inline = False , dedent = True , line_nums = False , line_start = 1 ) \u00b6 A code-snippet highlighting function for Jinja templates. Parameters: Name Type Description Default src str The code to highlight. required guess_lang bool Whether to guess the language or not. False language str Explicitly tell what language to use for highlighting. None inline bool Whether to do inline highlighting. False dedent bool Whether to dedent the code before highlighting it or not. True line_nums bool Whether to add line numbers in the result. False line_start int The line number to start with. 1 Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in mkdocstrings/handlers/__init__.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def do_highlight ( src : str , guess_lang : bool = False , language : str = None , inline : bool = False , dedent : bool = True , line_nums : bool = False , line_start : int = 1 , ) -> str : \"\"\" A code-snippet highlighting function for Jinja templates. Args: src: The code to highlight. guess_lang: Whether to guess the language or not. language: Explicitly tell what language to use for highlighting. inline: Whether to do inline highlighting. dedent: Whether to dedent the code before highlighting it or not. line_nums: Whether to add line numbers in the result. line_start: The line number to start with. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if dedent : src = textwrap . dedent ( src ) highlighter = Highlight ( use_pygments = True , guess_lang = guess_lang , linenums = line_nums ) result = highlighter . highlight ( src = src , language = language , linestart = line_start , inline = inline ) if inline : return do_mark_safe ( result . text ) return do_mark_safe ( result ) get_handler ( name , theme ) \u00b6 Get a handler thanks to its name. This function dynamically import a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required theme str The name of the theme to use. required Returns: Type Description BaseHandler An instance of a subclass of [ BaseHandler ][mkdocstrings.handlers.BaseHandler], as instantiated by the get_handler method of the handler's module. Source code in mkdocstrings/handlers/__init__.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def get_handler ( name : str , theme : str ) -> BaseHandler : \"\"\" Get a handler thanks to its name. This function dynamically import a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Args: name: The name of the handler. Really, it's the name of the Python module holding it. theme: The name of the theme to use. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in HANDLERS_CACHE : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) HANDLERS_CACHE [ name ] = module . get_handler ( theme ) return HANDLERS_CACHE [ name ] teardown () \u00b6 Teardown all cached handlers and clear the cache. Source code in mkdocstrings/handlers/__init__.py 237 238 239 240 241 242 243 244 def teardown () -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in HANDLERS_CACHE . values (): handler . collector . teardown () del handler . collector del handler . renderer del handler HANDLERS_CACHE . clear ()","title":"__init__.py"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers","text":"Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache.","title":"mkdocstrings.handlers"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector","text":"The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method.","title":"BaseCollector"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector.collect","text":"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description Type[ForwardRef('T')] Anything you want, as long as you can feed it to the renderer's render method. Source code in mkdocstrings/handlers/__init__.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def collect ( self , identifier : str , config : dict ) -> DataType : \"\"\" Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Args: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" raise NotImplementedError","title":"collect()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector.teardown","text":"Placeholder to remember this method can be implemented. Source code in mkdocstrings/handlers/__init__.py 189 190 def teardown ( self ) -> None : \"\"\"Placeholder to remember this method can be implemented.\"\"\"","title":"teardown()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseHandler","text":"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need.","title":"BaseHandler"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseHandler.__init__","text":"Initialization method. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in mkdocstrings/handlers/__init__.py 202 203 204 205 206 207 208 209 210 211 def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\" Initialization method. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer","title":"__init__()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer","text":"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a FALLBACK_THEME class-variable.","title":"BaseRenderer"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.__init__","text":"Initialization method. If the given theme is not supported (it does not exist), it will look for a FALLBACK_THEME attribute in self to use as a fallback theme. Parameters: Name Type Description Default directory str The name of the directory containing the themes for this renderer. required theme str The name of theme to use. required Source code in mkdocstrings/handlers/__init__.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 def __init__ ( self , directory : str , theme : str ) -> None : \"\"\" Initialization method. If the given theme is not supported (it does not exist), it will look for a `FALLBACK_THEME` attribute in `self` to use as a fallback theme. Arguments: directory: The name of the directory containing the themes for this renderer. theme: The name of theme to use. \"\"\" themes_dir = Path ( __file__ ) . parent . parent / \"templates\" / directory theme_dir = themes_dir / theme if not theme_dir . exists (): if self . FALLBACK_THEME != \"\" : log . warning ( f \"mkdocstrings.handlers: No ' { theme } ' theme in ' { directory } ', \" f \"falling back to theme ' { self . FALLBACK_THEME } '\" ) theme_dir = themes_dir / self . FALLBACK_THEME else : raise ThemeNotSupported ( theme ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( str ( theme_dir ))) self . env . filters [ \"highlight\" ] = do_highlight self . env . filters [ \"any\" ] = do_any","title":"__init__()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data Type[ForwardRef('T')] The collected data to render. required config dict The rendering options. required Returns: Type Description str The renderer template as HTML. Source code in mkdocstrings/handlers/__init__.py 130 131 132 133 134 135 136 137 138 139 140 141 def render ( self , data : DataType , config : dict ) -> str : \"\"\" Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The renderer template as HTML. \"\"\" raise NotImplementedError","title":"render()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/__init__.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def update_env ( self , md : Markdown , config : dict ) -> None : \"\"\" Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" md = Markdown ( extensions = config [ \"mdx\" ], extensions_configs = config [ \"mdx_configs\" ]) def convert_markdown ( text ): return do_mark_safe ( md . convert ( text )) self . env . filters [ \"convert_markdown\" ] = convert_markdown","title":"update_env()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.CollectionError","text":"An exception raised when some collection of data failed.","title":"CollectionError"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.ThemeNotSupported","text":"An exception raised to tell a theme is not supported.","title":"ThemeNotSupported"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.do_any","text":"The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in mkdocstrings/handlers/__init__.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\" The `any` builtin as a filter for Jinja templates. Args: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( o [ attribute ] for o in seq )","title":"do_any()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.do_highlight","text":"A code-snippet highlighting function for Jinja templates. Parameters: Name Type Description Default src str The code to highlight. required guess_lang bool Whether to guess the language or not. False language str Explicitly tell what language to use for highlighting. None inline bool Whether to do inline highlighting. False dedent bool Whether to dedent the code before highlighting it or not. True line_nums bool Whether to add line numbers in the result. False line_start int The line number to start with. 1 Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in mkdocstrings/handlers/__init__.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def do_highlight ( src : str , guess_lang : bool = False , language : str = None , inline : bool = False , dedent : bool = True , line_nums : bool = False , line_start : int = 1 , ) -> str : \"\"\" A code-snippet highlighting function for Jinja templates. Args: src: The code to highlight. guess_lang: Whether to guess the language or not. language: Explicitly tell what language to use for highlighting. inline: Whether to do inline highlighting. dedent: Whether to dedent the code before highlighting it or not. line_nums: Whether to add line numbers in the result. line_start: The line number to start with. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if dedent : src = textwrap . dedent ( src ) highlighter = Highlight ( use_pygments = True , guess_lang = guess_lang , linenums = line_nums ) result = highlighter . highlight ( src = src , language = language , linestart = line_start , inline = inline ) if inline : return do_mark_safe ( result . text ) return do_mark_safe ( result )","title":"do_highlight()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.get_handler","text":"Get a handler thanks to its name. This function dynamically import a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required theme str The name of the theme to use. required Returns: Type Description BaseHandler An instance of a subclass of [ BaseHandler ][mkdocstrings.handlers.BaseHandler], as instantiated by the get_handler method of the handler's module. Source code in mkdocstrings/handlers/__init__.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def get_handler ( name : str , theme : str ) -> BaseHandler : \"\"\" Get a handler thanks to its name. This function dynamically import a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Args: name: The name of the handler. Really, it's the name of the Python module holding it. theme: The name of the theme to use. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in HANDLERS_CACHE : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) HANDLERS_CACHE [ name ] = module . get_handler ( theme ) return HANDLERS_CACHE [ name ]","title":"get_handler()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.teardown","text":"Teardown all cached handlers and clear the cache. Source code in mkdocstrings/handlers/__init__.py 237 238 239 240 241 242 243 244 def teardown () -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in HANDLERS_CACHE . values (): handler . collector . teardown () del handler . collector del handler . renderer del handler HANDLERS_CACHE . clear ()","title":"teardown()"},{"location":"reference/handlers/python/","text":"\u00b6 This module implements a handler for the Python language. The handler collects data with pytkdocs . PythonCollector \u00b6 The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer]. DEFAULT_CONFIG: dict class-attribute \u00b6 The default selection options. Option Type Description Default filters List[str] Filter members with regular expressions. [ \"!^_[^_]\" ] members Union[bool, List[str]] Explicitly select the object members. pytkdocs default: True If members is a list of names, filters are applied only on the members children (not the members themselves). If members is False , none are selected. If members is True or an empty list, filters are applied on all members and their children. Members affect only the first layer of objects, while filters affect the whole object-tree recursively. Every filters is run against every object name. An object can be un-selected by a filter and re-selected by the next one: \"!^_\" : exclude all objects starting with an underscore `\"^__\": but select all objects starting with two underscores Obviously one could use a single filter instead: \"!^_[^_]\" , which is the default. __init__ ( self ) special \u00b6 Initialization method. When instantiating a Python collector, we open a subprocess in the background with subprocess.Popen . It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down mkdocstrings a lot. Source code in mkdocstrings/handlers/python.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self ) -> None : \"\"\" Initialization method. When instantiating a Python collector, we open a subprocess in the background with `subprocess.Popen`. It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down `mkdocstrings` a lot. \"\"\" log . debug ( \"mkdocstrings.handlers.python: Opening 'pytkdocs' subprocess\" ) env = os . environ . copy () env [ \"PYTHONUNBUFFERED\" ] = \"1\" self . process = Popen ( # nosec: there's no way to give the full path to the executable, is there? [ \"pytkdocs\" , \"--line-by-line\" ], universal_newlines = True , stderr = PIPE , stdout = PIPE , stdin = PIPE , bufsize =- 1 , env = env , ) collect ( self , identifier , config ) \u00b6 Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an error key, we log it as error (with the optional traceback value), and raise a CollectionError. If the dictionary values for keys loading_errors and parsing_errors are not empty, we log them as warnings. Then we pick up the only object within the objects list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [ rebuild_category_lists() ][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Parameters: Name Type Description Default identifier str The dotted-path of a Python object available in the Python path. required config dict Selection options, used to alter the data collection done by pytkdocs . required Returns: Type Description Type[ForwardRef('T')] The collected object-tree. Source code in mkdocstrings/handlers/python.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def collect ( self , identifier : str , config : dict ) -> DataType : \"\"\" Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an `error` key, we log it as error (with the optional `traceback` value), and raise a CollectionError. If the dictionary values for keys `loading_errors` and `parsing_errors` are not empty, we log them as warnings. Then we pick up the only object within the `objects` list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [`rebuild_category_lists()`][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Arguments: identifier: The dotted-path of a Python object available in the Python path. config: Selection options, used to alter the data collection done by `pytkdocs`. Returns: The collected object-tree. \"\"\" final_config = dict ( self . DEFAULT_CONFIG ) final_config . update ( config ) log . debug ( \"mkdocstrings.handlers.python: Preparing input\" ) json_input = json . dumps ({ \"objects\" : [{ \"path\" : identifier , ** final_config }]}) log . debug ( \"mkdocstrings.handlers.python: Writing to process' stdin\" ) print ( json_input , file = self . process . stdin , flush = True ) log . debug ( \"mkdocstrings.handlers.python: Reading process' stdout\" ) stdout = self . process . stdout . readline () # type: ignore log . debug ( \"mkdocstrings.handlers.python: Loading JSON output as Python object\" ) try : result = json . loads ( stdout ) except json . decoder . JSONDecodeError as error : log . error ( f \"mkdocstrings.handlers.python: Error while loading JSON: { stdout } \" ) raise CollectionError ( str ( error )) if \"error\" in result : message = f \"mkdocstrings.handlers.python: Collection failed: { result [ 'error' ] } \" if \"traceback\" in result : message += f \" \\n { result [ 'traceback' ] } \" log . error ( message ) raise CollectionError ( result [ \"error\" ]) if result [ \"loading_errors\" ]: for error in result [ \"loading_errors\" ]: # type: ignore log . warning ( f \"mkdocstrings.handlers.python: { error } \" ) if result [ \"parsing_errors\" ]: for path , errors in result [ \"parsing_errors\" ] . items (): # type: ignore for error in errors : log . warning ( f \"mkdocstrings.handlers.python: { error } \" ) # We always collect only one object at a time result = result [ \"objects\" ][ 0 ] log . debug ( \"mkdocstrings.handlers.python: Rebuilding categories and children lists\" ) rebuild_category_lists ( result ) return result teardown ( self ) \u00b6 Terminate the opened subprocess, set it to None. Source code in mkdocstrings/handlers/python.py 223 224 225 226 def teardown ( self ) -> None : \"\"\"Terminate the opened subprocess, set it to None.\"\"\" log . debug ( \"mkdocstrings.handlers.python: Tearing process down\" ) self . process . terminate () PythonHandler \u00b6 The Python handler class, nothing specific here. PythonRenderer \u00b6 The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer]. DEFAULT_CONFIG: dict class-attribute \u00b6 The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2 render ( self , data , config ) \u00b6 Render a template using provided data and configuration options. Parameters: Name Type Description Default data Type[ForwardRef('T')] The collected data to render. required config dict The rendering options. required Returns: Type Description str The renderer template as HTML. Source code in mkdocstrings/handlers/python.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def render ( self , data : DataType , config : dict ) -> str : final_config = dict ( self . DEFAULT_CONFIG ) final_config . update ( config ) template = self . env . get_template ( f \" { data [ 'category' ] } .html\" ) # Heading level is a \"state\" variable, that will change at each step # of the rendering recursion. Therefore, it's easier to use it as a plain value # instead of as an item in a dictionary. heading_level = final_config . pop ( \"heading_level\" ) return template . render ( ** { \"config\" : final_config , data [ \"category\" ]: data , \"heading_level\" : heading_level , \"root\" : True } ) update_env ( self , md , config ) \u00b6 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/python.py 69 70 71 72 73 def update_env ( self , md : Markdown , config : dict ) -> None : super ( PythonRenderer , self ) . update_env ( md , config ) self . env . trim_blocks = True self . env . lstrip_blocks = True self . env . keep_trailing_newline = False get_handler ( theme ) \u00b6 Simply return an instance of PythonHandler . Parameters: Name Type Description Default theme str The theme to use when rendering contents. required Returns: Type Description PythonHandler An instance of PythonHandler . Source code in mkdocstrings/handlers/python.py 233 234 235 236 237 238 239 240 241 242 243 def get_handler ( theme : str ) -> PythonHandler : \"\"\" Simply return an instance of `PythonHandler`. Arguments: theme: The theme to use when rendering contents. Returns: An instance of `PythonHandler`. \"\"\" return PythonHandler ( collector = PythonCollector (), renderer = PythonRenderer ( \"python\" , theme )) rebuild_category_lists ( obj ) \u00b6 Recursively rebuild the category lists of a collected object. Since pytkdocs dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a children list, containing all children, and another list for each category of children: attributes , classes , functions , methods and modules . It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the children list using their path. For each object, we recurse on every one of its children. Parameters: Name Type Description Default obj dict The collected object, loaded back from JSON into a Python dictionary. required Source code in mkdocstrings/handlers/python.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def rebuild_category_lists ( obj : dict ) -> None : \"\"\" Recursively rebuild the category lists of a collected object. Since `pytkdocs` dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a `children` list, containing all children, and another list for each category of children: `attributes`, `classes`, `functions`, `methods` and `modules`. It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the `children` list using their path. For each object, we recurse on every one of its children. Args: obj: The collected object, loaded back from JSON into a Python dictionary. \"\"\" obj [ \"attributes\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"attributes\" ]] obj [ \"classes\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"classes\" ]] obj [ \"functions\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"functions\" ]] obj [ \"methods\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"methods\" ]] obj [ \"modules\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"modules\" ]] obj [ \"children\" ] = [ v for k , v in obj [ \"children\" ] . items ()] for child in obj [ \"children\" ]: rebuild_category_lists ( child )","title":"python.py"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python","text":"This module implements a handler for the Python language. The handler collects data with pytkdocs .","title":"mkdocstrings.handlers.python"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector","text":"The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer].","title":"PythonCollector"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.DEFAULT_CONFIG","text":"The default selection options. Option Type Description Default filters List[str] Filter members with regular expressions. [ \"!^_[^_]\" ] members Union[bool, List[str]] Explicitly select the object members. pytkdocs default: True If members is a list of names, filters are applied only on the members children (not the members themselves). If members is False , none are selected. If members is True or an empty list, filters are applied on all members and their children. Members affect only the first layer of objects, while filters affect the whole object-tree recursively. Every filters is run against every object name. An object can be un-selected by a filter and re-selected by the next one: \"!^_\" : exclude all objects starting with an underscore `\"^__\": but select all objects starting with two underscores Obviously one could use a single filter instead: \"!^_[^_]\" , which is the default.","title":"DEFAULT_CONFIG"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.__init__","text":"Initialization method. When instantiating a Python collector, we open a subprocess in the background with subprocess.Popen . It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down mkdocstrings a lot. Source code in mkdocstrings/handlers/python.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self ) -> None : \"\"\" Initialization method. When instantiating a Python collector, we open a subprocess in the background with `subprocess.Popen`. It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down `mkdocstrings` a lot. \"\"\" log . debug ( \"mkdocstrings.handlers.python: Opening 'pytkdocs' subprocess\" ) env = os . environ . copy () env [ \"PYTHONUNBUFFERED\" ] = \"1\" self . process = Popen ( # nosec: there's no way to give the full path to the executable, is there? [ \"pytkdocs\" , \"--line-by-line\" ], universal_newlines = True , stderr = PIPE , stdout = PIPE , stdin = PIPE , bufsize =- 1 , env = env , )","title":"__init__()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.collect","text":"Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an error key, we log it as error (with the optional traceback value), and raise a CollectionError. If the dictionary values for keys loading_errors and parsing_errors are not empty, we log them as warnings. Then we pick up the only object within the objects list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [ rebuild_category_lists() ][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Parameters: Name Type Description Default identifier str The dotted-path of a Python object available in the Python path. required config dict Selection options, used to alter the data collection done by pytkdocs . required Returns: Type Description Type[ForwardRef('T')] The collected object-tree. Source code in mkdocstrings/handlers/python.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def collect ( self , identifier : str , config : dict ) -> DataType : \"\"\" Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an `error` key, we log it as error (with the optional `traceback` value), and raise a CollectionError. If the dictionary values for keys `loading_errors` and `parsing_errors` are not empty, we log them as warnings. Then we pick up the only object within the `objects` list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [`rebuild_category_lists()`][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Arguments: identifier: The dotted-path of a Python object available in the Python path. config: Selection options, used to alter the data collection done by `pytkdocs`. Returns: The collected object-tree. \"\"\" final_config = dict ( self . DEFAULT_CONFIG ) final_config . update ( config ) log . debug ( \"mkdocstrings.handlers.python: Preparing input\" ) json_input = json . dumps ({ \"objects\" : [{ \"path\" : identifier , ** final_config }]}) log . debug ( \"mkdocstrings.handlers.python: Writing to process' stdin\" ) print ( json_input , file = self . process . stdin , flush = True ) log . debug ( \"mkdocstrings.handlers.python: Reading process' stdout\" ) stdout = self . process . stdout . readline () # type: ignore log . debug ( \"mkdocstrings.handlers.python: Loading JSON output as Python object\" ) try : result = json . loads ( stdout ) except json . decoder . JSONDecodeError as error : log . error ( f \"mkdocstrings.handlers.python: Error while loading JSON: { stdout } \" ) raise CollectionError ( str ( error )) if \"error\" in result : message = f \"mkdocstrings.handlers.python: Collection failed: { result [ 'error' ] } \" if \"traceback\" in result : message += f \" \\n { result [ 'traceback' ] } \" log . error ( message ) raise CollectionError ( result [ \"error\" ]) if result [ \"loading_errors\" ]: for error in result [ \"loading_errors\" ]: # type: ignore log . warning ( f \"mkdocstrings.handlers.python: { error } \" ) if result [ \"parsing_errors\" ]: for path , errors in result [ \"parsing_errors\" ] . items (): # type: ignore for error in errors : log . warning ( f \"mkdocstrings.handlers.python: { error } \" ) # We always collect only one object at a time result = result [ \"objects\" ][ 0 ] log . debug ( \"mkdocstrings.handlers.python: Rebuilding categories and children lists\" ) rebuild_category_lists ( result ) return result","title":"collect()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.teardown","text":"Terminate the opened subprocess, set it to None. Source code in mkdocstrings/handlers/python.py 223 224 225 226 def teardown ( self ) -> None : \"\"\"Terminate the opened subprocess, set it to None.\"\"\" log . debug ( \"mkdocstrings.handlers.python: Tearing process down\" ) self . process . terminate ()","title":"teardown()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonHandler","text":"The Python handler class, nothing specific here.","title":"PythonHandler"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer","text":"The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer].","title":"PythonRenderer"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.DEFAULT_CONFIG","text":"The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2","title":"DEFAULT_CONFIG"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data Type[ForwardRef('T')] The collected data to render. required config dict The rendering options. required Returns: Type Description str The renderer template as HTML. Source code in mkdocstrings/handlers/python.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def render ( self , data : DataType , config : dict ) -> str : final_config = dict ( self . DEFAULT_CONFIG ) final_config . update ( config ) template = self . env . get_template ( f \" { data [ 'category' ] } .html\" ) # Heading level is a \"state\" variable, that will change at each step # of the rendering recursion. Therefore, it's easier to use it as a plain value # instead of as an item in a dictionary. heading_level = final_config . pop ( \"heading_level\" ) return template . render ( ** { \"config\" : final_config , data [ \"category\" ]: data , \"heading_level\" : heading_level , \"root\" : True } )","title":"render()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/python.py 69 70 71 72 73 def update_env ( self , md : Markdown , config : dict ) -> None : super ( PythonRenderer , self ) . update_env ( md , config ) self . env . trim_blocks = True self . env . lstrip_blocks = True self . env . keep_trailing_newline = False","title":"update_env()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.get_handler","text":"Simply return an instance of PythonHandler . Parameters: Name Type Description Default theme str The theme to use when rendering contents. required Returns: Type Description PythonHandler An instance of PythonHandler . Source code in mkdocstrings/handlers/python.py 233 234 235 236 237 238 239 240 241 242 243 def get_handler ( theme : str ) -> PythonHandler : \"\"\" Simply return an instance of `PythonHandler`. Arguments: theme: The theme to use when rendering contents. Returns: An instance of `PythonHandler`. \"\"\" return PythonHandler ( collector = PythonCollector (), renderer = PythonRenderer ( \"python\" , theme ))","title":"get_handler()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.rebuild_category_lists","text":"Recursively rebuild the category lists of a collected object. Since pytkdocs dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a children list, containing all children, and another list for each category of children: attributes , classes , functions , methods and modules . It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the children list using their path. For each object, we recurse on every one of its children. Parameters: Name Type Description Default obj dict The collected object, loaded back from JSON into a Python dictionary. required Source code in mkdocstrings/handlers/python.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def rebuild_category_lists ( obj : dict ) -> None : \"\"\" Recursively rebuild the category lists of a collected object. Since `pytkdocs` dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a `children` list, containing all children, and another list for each category of children: `attributes`, `classes`, `functions`, `methods` and `modules`. It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the `children` list using their path. For each object, we recurse on every one of its children. Args: obj: The collected object, loaded back from JSON into a Python dictionary. \"\"\" obj [ \"attributes\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"attributes\" ]] obj [ \"classes\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"classes\" ]] obj [ \"functions\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"functions\" ]] obj [ \"methods\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"methods\" ]] obj [ \"modules\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"modules\" ]] obj [ \"children\" ] = [ v for k , v in obj [ \"children\" ] . items ()] for child in obj [ \"children\" ]: rebuild_category_lists ( child )","title":"rebuild_category_lists()"}]}