{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocstrings Automatic documentation from docstrings, for mkdocs. This plugin is still in alpha status. Here is how it looks with the mkdocs-material theme for now: Features Works great with Material theme: mkdocstrings was designed to work best with the great Material theme . Support for type annotations: mkdocstrings uses your type annotations to display parameters types or return types. Recursive documentation of Python objects: just write the module dotted-path, and you get the full module docs. No need to ask for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by mkdocstrings , in modules, classes and even in __init__ methods. Support for objects properties: mkdocstrings will know if a method is a staticmethod , a classmethod or else, it will also know if a property is read-only or writable, and more! These properties will be displayed next to the object signature. Every object has a TOC entry and a unique permalink: the navigation is greatly improved! Click the anchor next to the object signature to get its permalink, which is its Python dotted-path. Auto-reference other objects: mkdocstrings makes it possible to reference other Python objects from your markdown files, and even from your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] . Google-style sections support in docstrings: mkdocstrings understands Arguments: , Raises: and Returns: sections. It will even keep the section order in the generated docs. Support for source code display: mkdocstrings can add a collapsible div containing the source code of the Python object, directly below its signature, with the right line numbers. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Sane defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs. Configurable: (soon) mkdocstrings is configurable globally, and per autodoc instruction. To get an example of what is possible, check mkdocstrings ' own documentation , generated with itself. Requirements mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 Installation With pip : python3.6 -m pip install mkdocstrings Usage # mkdocs.yml # designed to work best with material theme theme : name : \"material\" plugins : - search - mkdocstrings In one of your markdown files: # Reference ::: my_library.my_module.my_class You can reference objects from other modules in your docstrings: def some_function (): \"\"\" This is my function. It references [another function][package.submodule.function]. It also references another object directly: [package.submodule.SuperClass][]. \"\"\" pass Add some style in docs/custom.css : div . autodoc { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); } And add it to your configuration: extra_css : - custom.css Docstrings format Your docstrings must follow a particular format, otherwise mkdocstrings will throw an exception. This will be improved to be more robust over time. from typing import Optional def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\" A short description of this function. A longer description of this function. You can use more lines. This is code block, as usual. ```python s = \"This is a Python code block :)\" ``` Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines with at least two more spaces. They will all be concatenated in one line, so do not try to use complex markup here. Important: Note how we omitted the type hints next to the parameters names. Usually you would write something like `param1 (int): ...`, but `mkdocstrings` gets the type information from the signature, so it's not needed here. Exceptions are written the same. Raises: OSError: Explain when this error is thrown. RuntimeError: Explain as well. Multi-line description, etc. Let's see the return value section now. Returns: A description of the value that is returned. Again multiple lines are allowed. They will also be concatenated to one line, so do not use complex markup here. Note: Other words are supported: - `Args`, `Arguments`, `Params` and `Parameters` for the parameters. - `Raise`, `Raises`, `Except`, and `Exceptions` for exceptions. - `Return` or `Returns` for return value. They are all case-insensitive, so you can write `RETURNS:` or `params:`. \"\"\" return f \" {param2}{param1} \" This docstring would be rendered like this (had to take two screenshots, so it's not perfectly aligned):","title":"Overview"},{"location":"#mkdocstrings","text":"Automatic documentation from docstrings, for mkdocs. This plugin is still in alpha status. Here is how it looks with the mkdocs-material theme for now:","title":"mkdocstrings"},{"location":"#features","text":"Works great with Material theme: mkdocstrings was designed to work best with the great Material theme . Support for type annotations: mkdocstrings uses your type annotations to display parameters types or return types. Recursive documentation of Python objects: just write the module dotted-path, and you get the full module docs. No need to ask for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by mkdocstrings , in modules, classes and even in __init__ methods. Support for objects properties: mkdocstrings will know if a method is a staticmethod , a classmethod or else, it will also know if a property is read-only or writable, and more! These properties will be displayed next to the object signature. Every object has a TOC entry and a unique permalink: the navigation is greatly improved! Click the anchor next to the object signature to get its permalink, which is its Python dotted-path. Auto-reference other objects: mkdocstrings makes it possible to reference other Python objects from your markdown files, and even from your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] . Google-style sections support in docstrings: mkdocstrings understands Arguments: , Raises: and Returns: sections. It will even keep the section order in the generated docs. Support for source code display: mkdocstrings can add a collapsible div containing the source code of the Python object, directly below its signature, with the right line numbers. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Sane defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs. Configurable: (soon) mkdocstrings is configurable globally, and per autodoc instruction. To get an example of what is possible, check mkdocstrings ' own documentation , generated with itself.","title":"Features"},{"location":"#requirements","text":"mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install mkdocstrings","title":"Installation"},{"location":"#usage","text":"# mkdocs.yml # designed to work best with material theme theme : name : \"material\" plugins : - search - mkdocstrings In one of your markdown files: # Reference ::: my_library.my_module.my_class You can reference objects from other modules in your docstrings: def some_function (): \"\"\" This is my function. It references [another function][package.submodule.function]. It also references another object directly: [package.submodule.SuperClass][]. \"\"\" pass Add some style in docs/custom.css : div . autodoc { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); } And add it to your configuration: extra_css : - custom.css","title":"Usage"},{"location":"#docstrings-format","text":"Your docstrings must follow a particular format, otherwise mkdocstrings will throw an exception. This will be improved to be more robust over time. from typing import Optional def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\" A short description of this function. A longer description of this function. You can use more lines. This is code block, as usual. ```python s = \"This is a Python code block :)\" ``` Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines with at least two more spaces. They will all be concatenated in one line, so do not try to use complex markup here. Important: Note how we omitted the type hints next to the parameters names. Usually you would write something like `param1 (int): ...`, but `mkdocstrings` gets the type information from the signature, so it's not needed here. Exceptions are written the same. Raises: OSError: Explain when this error is thrown. RuntimeError: Explain as well. Multi-line description, etc. Let's see the return value section now. Returns: A description of the value that is returned. Again multiple lines are allowed. They will also be concatenated to one line, so do not use complex markup here. Note: Other words are supported: - `Args`, `Arguments`, `Params` and `Parameters` for the parameters. - `Raise`, `Raises`, `Except`, and `Exceptions` for exceptions. - `Return` or `Returns` for return value. They are all case-insensitive, so you can write `RETURNS:` or `params:`. \"\"\" return f \" {param2}{param1} \" This docstring would be rendered like this (had to take two screenshots, so it's not perfectly aligned):","title":"Docstrings format"},{"location":"changelog/","text":"Changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. For bug reports, feature requests, and feedback, simply create a new issue . Try to be as descriptive as possible. Bug fixes, new features and documentation This project is developed using poetry . Follow the recommended installation method: curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Then follow these instructions: Fork the repository on github.com ; Clone it on your machine; Go into the directory, and run poetry install to setup the development environment; Create a new branch with git checkout -b bug-fix-or-feature-name ; Code! Write tests. Run them all. The commands to run the tests are: poetry run pytest # to run all tests sequentially poetry run pytest -v # to print one test per line poetry run pytest -n 4 # to run tests in parallel (4 workers) poetry run pytest tests/test_api.py # to run tests in a specific file pytest provides the -k option to select tests based on their names: poetry run pytest -k \"api and remove\" poetry run pytest -k \"utils or stats\" See the documentation for the -k option for more examples. A Makefile is available for convenience: make test . When the tests pass, commit (make sure to have atomic commits and contextual commit messages! Check out this awesome blog post by Chris Beams for more information. ) Push; ...and finally, create a new pull/merge request ! Make sure to follow the guidelines.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. For bug reports, feature requests, and feedback, simply create a new issue . Try to be as descriptive as possible.","title":"Contributing"},{"location":"contributing/#bug-fixes-new-features-and-documentation","text":"This project is developed using poetry . Follow the recommended installation method: curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Then follow these instructions: Fork the repository on github.com ; Clone it on your machine; Go into the directory, and run poetry install to setup the development environment; Create a new branch with git checkout -b bug-fix-or-feature-name ; Code! Write tests. Run them all. The commands to run the tests are: poetry run pytest # to run all tests sequentially poetry run pytest -v # to print one test per line poetry run pytest -n 4 # to run tests in parallel (4 workers) poetry run pytest tests/test_api.py # to run tests in a specific file pytest provides the -k option to select tests based on their names: poetry run pytest -k \"api and remove\" poetry run pytest -k \"utils or stats\" See the documentation for the -k option for more examples. A Makefile is available for convenience: make test . When the tests pass, commit (make sure to have atomic commits and contextual commit messages! Check out this awesome blog post by Chris Beams for more information. ) Push; ...and finally, create a new pull/merge request ! Make sure to follow the guidelines.","title":"Bug fixes, new features and documentation"},{"location":"credits/","text":"Credits These projects were used to build mkdocstrings . Thank you! python | poetry | cookie-poetry Direct dependencies bandit | black | coverage | flake8 | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | pylint | pytest | pytest-cov | pytest-sugar | pytest-xdist | safety | toml Indirect dependencies apipkg | appdirs | appnope | astroid | atomicwrites | attrs | backcall | certifi | chardet | Click | colorama | decorator | dparse | entrypoints | execnet | gitdb2 | GitPython | htmlmin | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | jsmin | lazy-object-proxy | livereload | Markdown | MarkupSafe | mccabe | mkdocs-minify-plugin | more-itertools | packaging | parso | pathspec | pbr | pep562 | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | requests | six | smmap2 | stevedore | termcolor | tornado | traitlets | typed-ast | urllib3 | wcwidth | wrapt | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build mkdocstrings . Thank you! python | poetry | cookie-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"bandit | black | coverage | flake8 | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | pylint | pytest | pytest-cov | pytest-sugar | pytest-xdist | safety | toml","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"apipkg | appdirs | appnope | astroid | atomicwrites | attrs | backcall | certifi | chardet | Click | colorama | decorator | dparse | entrypoints | execnet | gitdb2 | GitPython | htmlmin | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | jsmin | lazy-object-proxy | livereload | Markdown | MarkupSafe | mccabe | mkdocs-minify-plugin | more-itertools | packaging | parso | pathspec | pbr | pep562 | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | PyYAML | regex | requests | six | smmap2 | stevedore | termcolor | tornado | traitlets | typed-ast | urllib3 | wcwidth | wrapt | zipp More credits from the author","title":"Indirect dependencies"},{"location":"reference/docstrings/","text":"Docstring \u00b6 parse ( self ) \u00b6 Show source code in mkdocstrings/docstrings.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def parse ( self ) -> List [ Section ]: \"\"\" Parse a docstring! Note: to try notes. Returns: The docstring converted to a nice markdown text. \"\"\" sections = [] current_block = [] in_code_block = False lines = self . original_value . split ( \" \\n \" ) i = 0 while i < len ( lines ): line_lower = lines [ i ] . lower () if line_lower in TITLES_PARAMETERS : if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) current_block = [] section , i = self . read_parameters_section ( lines , i + 1 ) sections . append ( section ) elif line_lower in TITLES_EXCEPTIONS : if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) current_block = [] section , i = self . read_exceptions_section ( lines , i + 1 ) sections . append ( section ) elif line_lower in TITLES_RETURN : if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) current_block = [] section , i = self . read_return_section ( lines , i + 1 ) if section : sections . append ( section ) elif ( not line_lower . startswith ( \" \" ) and line_lower . lstrip ( \" \" ) in ADMONITIONS . keys () and not in_code_block ): if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) current_block = [] section , i = self . read_admonition ( line_lower , lines , i + 1 ) sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = not in_code_block current_block . append ( lines [ i ]) else : current_block . append ( lines [ i ]) i += 1 if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) return sections Parse a docstring! Note to try notes. Returns Type Description List[mkdocstrings.docstrings.Section] The docstring converted to a nice markdown text.","title":"docstrings.py"},{"location":"reference/docstrings/#mkdocstrings.docstrings.Docstring","text":"","title":"Docstring"},{"location":"reference/docstrings/#mkdocstrings.docstrings.Docstring.parse","text":"Show source code in mkdocstrings/docstrings.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def parse ( self ) -> List [ Section ]: \"\"\" Parse a docstring! Note: to try notes. Returns: The docstring converted to a nice markdown text. \"\"\" sections = [] current_block = [] in_code_block = False lines = self . original_value . split ( \" \\n \" ) i = 0 while i < len ( lines ): line_lower = lines [ i ] . lower () if line_lower in TITLES_PARAMETERS : if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) current_block = [] section , i = self . read_parameters_section ( lines , i + 1 ) sections . append ( section ) elif line_lower in TITLES_EXCEPTIONS : if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) current_block = [] section , i = self . read_exceptions_section ( lines , i + 1 ) sections . append ( section ) elif line_lower in TITLES_RETURN : if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) current_block = [] section , i = self . read_return_section ( lines , i + 1 ) if section : sections . append ( section ) elif ( not line_lower . startswith ( \" \" ) and line_lower . lstrip ( \" \" ) in ADMONITIONS . keys () and not in_code_block ): if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) current_block = [] section , i = self . read_admonition ( line_lower , lines , i + 1 ) sections . append ( section ) elif line_lower . lstrip ( \" \" ) . startswith ( \"```\" ): in_code_block = not in_code_block current_block . append ( lines [ i ]) else : current_block . append ( lines [ i ]) i += 1 if current_block : sections . append ( Section ( Section . Type . MARKDOWN , current_block )) return sections Parse a docstring! Note to try notes. Returns Type Description List[mkdocstrings.docstrings.Section] The docstring converted to a nice markdown text.","title":"parse()"},{"location":"reference/documenter/","text":"This module is responsible for loading the documentation from Python objects and rendering it to Markdown. Here is how to use it: instantiate a Documenter instance with user configuration (currently only global filters). get an instance of a subclass of Object ( Module , Class , Method , Function , or Attribute ) with the documenter's get_object_documentation method. The method takes the dotted-path to an object as argument. Here is how we proceed: The documentation for an object is obtained recursively, by walking through its children objects (module classes, module functions, class methods, class attributes, class nested classes, etc.). Each one of the object is instantiated using its correct category (Module, Class, Method, or Function). The children of an object are organized into these same categories: modules , classes , methods , and functions . The attributes documentation is obtained by parsing the code with the ast module. We simply search for \"assignment\" or \"annotated assignment\" nodes followed by \"docstring\" nodes (expressions or strings). Attribute children are stored in an object's attributes attribute by dispatching them onto the object thanks to their dotted-paths. Each docstring is parsed to build a list of \"docstring sections\". Such a section can be a markdown block of lines, a block of parameters, a block of exceptions, an admonition, or the information about the return value. Exceptions and the return value are instances of AnnotatedObject , while parameters are instances of the Parameter class, which is a subclass of AnnotatedObject . To build these sections, we search for blocks matching the Google style for docstrings. For example: Note: This is a note. ...will be parsed as a \"note\" admonition, while: Arguments: param1: Description of param1. param2: Description of param2. Raises: OSError: When this exception is raised. RuntimeError: When this exception is raised. Returns: Description of the return value. ...will be parsed as \"parameters\", \"exceptions\" and \"return\" sections. Important Note the absence of type hints in the arguments and returns section: in mkdocstrings , the types are obtained using type annotations (using the typing module and builtin types), and not from type hints. It means that you must use type annotations in the signature of your function/method, or add a type annotation to an attribute. For example: def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> typing . Dict [ int , str ]: pass Documenter \u00b6 Class that contains the object documentation loading mechanisms. get_object_documentation ( self , import_string ) \u00b6 Show source code in mkdocstrings/documenter.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def get_object_documentation ( self , import_string : str ) -> Union [ Attribute , Method , Function , Module , Class ]: \"\"\" Documenting to see return type. Return: The object with all its children populated. \"\"\" module , obj = import_object ( import_string ) attributes = get_attributes ( module ) if inspect . ismodule ( obj ): root_object = self . get_module_documentation ( obj ) elif inspect . isclass ( obj ): root_object = self . get_class_documentation ( obj , module ) elif inspect . isfunction ( obj ): root_object = self . get_function_documentation ( obj , module ) else : raise ValueError ( f \" {obj} :{type(obj)} not yet supported\" ) root_object . dispatch_attributes ([ a for a in attributes if not self . filter_name_out ( a . name )]) return root_object Documenting to see return type. Returns Type Description Union[mkdocstrings.documenter.Attribute, mkdocstrings.documenter.Method, mkdocstrings.documenter.Function, mkdocstrings.documenter.Module, mkdocstrings.documenter.Class] The object with all its children populated. Object \u00b6 Generic class to store information about a Python object. Each instance additionally stores references to its children, grouped by category. attributes : List [ Attribute ] \u00b6 List of all the object's attributes. children : List [ Union [ Attribute , Method , Function , Module , Class ]] \u00b6 List of all the object's children. classes : List [ Class ] \u00b6 List of all the object's classes. functions : List [ Function ] \u00b6 List of all the object's functions. methods : List [ Method ] \u00b6 List of all the object's methods. modules : List [ Module ] \u00b6 List of all the object's submodules. parent_path : str (property, readonly) \u00b6 The parent's path, computed from the current path. __init__ ( self , name , path , file_path , docstring = None , properties = None , source = None ) \u00b6 Show source code in mkdocstrings/documenter.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def __init__ ( self , name : str , path : str , file_path : str , docstring : Optional [ \"Docstring\" ] = None , properties : Optional [ List [ str ]] = None , source : Optional [ Tuple [ int , List [ str ]]] = None , ) -> None : \"\"\" Parameters: name: The object name, like `__init__` or `MyClass`. path: The object dotted-path, like `package.submodule.class.inner_class.method`. file_path: The full file path of the object's module, like `/full/path/to/package/submodule.py`. docstring: A `Docstring` instance properties: A list of properties like `special`, `classmethod`, etc. source: A tuple with the object source code lines as a list, and the starting line in the object's module. \"\"\" self . name = name self . path = path self . file_path = file_path self . docstring = docstring self . properties = properties or [] self . parent = None self . source = source self . _path_map = { self . path : self } self . attributes : List [ Attribute ] = [] \"\"\"List of all the object's attributes.\"\"\" self . methods : List [ Method ] = [] \"\"\"List of all the object's methods.\"\"\" self . functions : List [ Function ] = [] \"\"\"List of all the object's functions.\"\"\" self . modules : List [ Module ] = [] \"\"\"List of all the object's submodules.\"\"\" self . classes : List [ Class ] = [] \"\"\"List of all the object's classes.\"\"\" self . children : List [ Union [ Attribute , Method , Function , Module , Class ]] = [] \"\"\"List of all the object's children.\"\"\" Parameters Name Type Description Default name str The object name, like __init__ or MyClass . required path str The object dotted-path, like package.submodule.class.inner_class.method . required file_path str The full file path of the object's module, like /full/path/to/package/submodule.py . required docstring Optional[Docstring] A Docstring instance None properties Optional[List[str]] A list of properties like special , classmethod , etc. None source Optional[Tuple[int, List[str]]] A tuple with the object source code lines as a list, and the starting line in the object's module. None add_child ( self , obj ) \u00b6 Show source code in mkdocstrings/documenter.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def add_child ( self , obj : Union [ \"Attribute\" , \"Method\" , \"Function\" , \"Module\" , \"Class\" ]) -> None : \"\"\" Add an object as a child of this object. Parameters: obj: An instance of documented object. \"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) if obj . is_module : self . modules . append ( obj ) elif obj . is_class : self . classes . append ( obj ) elif obj . is_function : self . functions . append ( obj ) elif obj . is_method : self . methods . append ( obj ) elif obj . is_attribute : self . attributes . append ( obj ) obj . parent = self self . _path_map [ obj . path ] = obj Add an object as a child of this object. Parameters Name Type Description Default obj Union[Attribute, Method, Function, Module, Class] An instance of documented object. required add_children ( self , children ) \u00b6 Show source code in mkdocstrings/documenter.py 239 240 241 242 def add_children ( self , children : List [ Union [ \"Attribute\" , \"Method\" , \"Function\" , \"Module\" , \"Class\" ]]) -> None : \"\"\"Add a list of objects as children of this object.\"\"\" for child in children : self . add_child ( child ) Add a list of objects as children of this object. import_object ( path ) \u00b6 Show source code in mkdocstrings/documenter.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 def import_object ( path : str ) -> Tuple [ ModuleType , Any ]: \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through ``importlib.import_module`` and each object is obtainable through the ``getattr`` method. Local objects will not work. Args: path: the dot-separated path of the object. Returns: The imported module and obtained object. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not {path} \" ) obj_parent_modules = path . split ( \".\" ) objects = [] while True : try : parent_module_path = \".\" . join ( obj_parent_modules ) parent_module = importlib . import_module ( parent_module_path ) break except ImportError : if len ( obj_parent_modules ) == 1 : raise ImportError ( \"No module named ' %s '\" % obj_parent_modules [ 0 ]) objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) current_object = parent_module for obj in objects : current_object = getattr ( current_object , obj ) module = inspect . getmodule ( current_object ) return module , current_object Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. Local objects will not work. Parameters Name Type Description Default path str the dot-separated path of the object. required Returns Type Description Tuple[module, Any] The imported module and obtained object.","title":"documenter.py"},{"location":"reference/documenter/#mkdocstrings.documenter.Documenter","text":"Class that contains the object documentation loading mechanisms.","title":"Documenter"},{"location":"reference/documenter/#mkdocstrings.documenter.Documenter.get_object_documentation","text":"Show source code in mkdocstrings/documenter.py 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 def get_object_documentation ( self , import_string : str ) -> Union [ Attribute , Method , Function , Module , Class ]: \"\"\" Documenting to see return type. Return: The object with all its children populated. \"\"\" module , obj = import_object ( import_string ) attributes = get_attributes ( module ) if inspect . ismodule ( obj ): root_object = self . get_module_documentation ( obj ) elif inspect . isclass ( obj ): root_object = self . get_class_documentation ( obj , module ) elif inspect . isfunction ( obj ): root_object = self . get_function_documentation ( obj , module ) else : raise ValueError ( f \" {obj} :{type(obj)} not yet supported\" ) root_object . dispatch_attributes ([ a for a in attributes if not self . filter_name_out ( a . name )]) return root_object Documenting to see return type. Returns Type Description Union[mkdocstrings.documenter.Attribute, mkdocstrings.documenter.Method, mkdocstrings.documenter.Function, mkdocstrings.documenter.Module, mkdocstrings.documenter.Class] The object with all its children populated.","title":"get_object_documentation()"},{"location":"reference/documenter/#mkdocstrings.documenter.Object","text":"Generic class to store information about a Python object. Each instance additionally stores references to its children, grouped by category.","title":"Object"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.attributes","text":"List of all the object's attributes.","title":"attributes"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.children","text":"List of all the object's children.","title":"children"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.classes","text":"List of all the object's classes.","title":"classes"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.functions","text":"List of all the object's functions.","title":"functions"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.methods","text":"List of all the object's methods.","title":"methods"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.modules","text":"List of all the object's submodules.","title":"modules"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.parent_path","text":"The parent's path, computed from the current path.","title":"parent_path"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.__init__","text":"Show source code in mkdocstrings/documenter.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def __init__ ( self , name : str , path : str , file_path : str , docstring : Optional [ \"Docstring\" ] = None , properties : Optional [ List [ str ]] = None , source : Optional [ Tuple [ int , List [ str ]]] = None , ) -> None : \"\"\" Parameters: name: The object name, like `__init__` or `MyClass`. path: The object dotted-path, like `package.submodule.class.inner_class.method`. file_path: The full file path of the object's module, like `/full/path/to/package/submodule.py`. docstring: A `Docstring` instance properties: A list of properties like `special`, `classmethod`, etc. source: A tuple with the object source code lines as a list, and the starting line in the object's module. \"\"\" self . name = name self . path = path self . file_path = file_path self . docstring = docstring self . properties = properties or [] self . parent = None self . source = source self . _path_map = { self . path : self } self . attributes : List [ Attribute ] = [] \"\"\"List of all the object's attributes.\"\"\" self . methods : List [ Method ] = [] \"\"\"List of all the object's methods.\"\"\" self . functions : List [ Function ] = [] \"\"\"List of all the object's functions.\"\"\" self . modules : List [ Module ] = [] \"\"\"List of all the object's submodules.\"\"\" self . classes : List [ Class ] = [] \"\"\"List of all the object's classes.\"\"\" self . children : List [ Union [ Attribute , Method , Function , Module , Class ]] = [] \"\"\"List of all the object's children.\"\"\" Parameters Name Type Description Default name str The object name, like __init__ or MyClass . required path str The object dotted-path, like package.submodule.class.inner_class.method . required file_path str The full file path of the object's module, like /full/path/to/package/submodule.py . required docstring Optional[Docstring] A Docstring instance None properties Optional[List[str]] A list of properties like special , classmethod , etc. None source Optional[Tuple[int, List[str]]] A tuple with the object source code lines as a list, and the starting line in the object's module. None","title":"__init__()"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.add_child","text":"Show source code in mkdocstrings/documenter.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def add_child ( self , obj : Union [ \"Attribute\" , \"Method\" , \"Function\" , \"Module\" , \"Class\" ]) -> None : \"\"\" Add an object as a child of this object. Parameters: obj: An instance of documented object. \"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) if obj . is_module : self . modules . append ( obj ) elif obj . is_class : self . classes . append ( obj ) elif obj . is_function : self . functions . append ( obj ) elif obj . is_method : self . methods . append ( obj ) elif obj . is_attribute : self . attributes . append ( obj ) obj . parent = self self . _path_map [ obj . path ] = obj Add an object as a child of this object. Parameters Name Type Description Default obj Union[Attribute, Method, Function, Module, Class] An instance of documented object. required","title":"add_child()"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.add_children","text":"Show source code in mkdocstrings/documenter.py 239 240 241 242 def add_children ( self , children : List [ Union [ \"Attribute\" , \"Method\" , \"Function\" , \"Module\" , \"Class\" ]]) -> None : \"\"\"Add a list of objects as children of this object.\"\"\" for child in children : self . add_child ( child ) Add a list of objects as children of this object.","title":"add_children()"},{"location":"reference/documenter/#mkdocstrings.documenter.import_object","text":"Show source code in mkdocstrings/documenter.py 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 def import_object ( path : str ) -> Tuple [ ModuleType , Any ]: \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through ``importlib.import_module`` and each object is obtainable through the ``getattr`` method. Local objects will not work. Args: path: the dot-separated path of the object. Returns: The imported module and obtained object. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not {path} \" ) obj_parent_modules = path . split ( \".\" ) objects = [] while True : try : parent_module_path = \".\" . join ( obj_parent_modules ) parent_module = importlib . import_module ( parent_module_path ) break except ImportError : if len ( obj_parent_modules ) == 1 : raise ImportError ( \"No module named ' %s '\" % obj_parent_modules [ 0 ]) objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) current_object = parent_module for obj in objects : current_object = getattr ( current_object , obj ) module = inspect . getmodule ( current_object ) return module , current_object Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. Local objects will not work. Parameters Name Type Description Default path str the dot-separated path of the object. required Returns Type Description Tuple[module, Any] The imported module and obtained object.","title":"import_object()"},{"location":"reference/plugin/","text":"Plugin module docstring. MkdocstringsPlugin \u00b6 The mkdocstrings plugin to use in your mkdocs configuration file. on_config ( self , config , ** kwargs ) \u00b6 Show source code in mkdocstrings/plugin.py 92 93 94 95 96 def on_config ( self , config , ** kwargs ): \"\"\"Initializes a [Documenter][mkdocstrings.documenter.Documenter].\"\"\" self . documenter = Documenter ( self . config [ \"global_filters\" ]) self . _main_config = config return config Initializes a Documenter .","title":"plugin.py"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin","text":"The mkdocstrings plugin to use in your mkdocs configuration file.","title":"MkdocstringsPlugin"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","text":"Show source code in mkdocstrings/plugin.py 92 93 94 95 96 def on_config ( self , config , ** kwargs ): \"\"\"Initializes a [Documenter][mkdocstrings.documenter.Documenter].\"\"\" self . documenter = Documenter ( self . config [ \"global_filters\" ]) self . _main_config = config return config Initializes a Documenter .","title":"on_config()"},{"location":"reference/renderer/","text":"","title":"renderer.py"}]}