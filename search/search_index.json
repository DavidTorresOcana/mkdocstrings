{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocstrings \u00a4 Automatic documentation from sources, for MkDocs. Features Python handler features Requirements Installation Usage Features \u00a4 Language agnostic: just like mkdocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it for any language, as long as you implement a handler for it. Currently, we only have a Python handler . Maybe you'd like to contribute another one ? Multiple themes support: each handler can offer multiple themes. Currently, we only offer the Material theme for the Python handler. Cross-references to other objects: mkdocstrings makes it possible to reference other headings from your Markdown files with the classic Markdown syntax: [identifier][] or [title][identifier] . This feature is language agnostic as well: you can cross-reference any heading that appear in your Markdown pages. If the handler for a particular language renders headings for documented objects, you'll be able to reference them! Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by mkdocs when serving the documentation, for auto-reload. Sane defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs. Python handler features \u00a4 Data collection from source code : collection of the object-tree and the docstrings is done by pytkdocs . The following features are possible thanks to it: Support for type annotations: pytkdocs collects your type annotations and mkdocstrings uses them to display parameters types or return types. Recursive documentation of Python objects: just use the module dotted-path as identifier, and you get the full module docs. You don't need to inject documentation for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by pytkdocs in modules, classes and even in __init__ methods. Support for objects properties: pytkdocs detects if a method is a staticmethod , a classmethod , etc., it also detects if a property is read-only or writable, and more! These properties will be displayed next to the object signature by mkdocstrings . Google-style sections support in docstrings: pytkdocs understands Arguments: , Raises: and Returns: sections, and returns structured data for mkdocstrings to render them. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Every object has a TOC entry: we render a heading for each object, meaning mkdocs picks them into the Table of Contents, which is nicely display by the Material theme. Thanks to mkdocstrings cross-reference ability, you can even reference other objects within your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] Source code display: mkdocstrings can add a collapsible div containing the highlighted source code of the Python object. To get an example of what is possible, check mkdocstrings ' own documentation , auto-generated from sources by itself of course, and the following GIF: Roadmap \u00a4 December-January 2020: Proof of Concept. January-March 2020: Refactor. March-April 2020: Test suite for pytkdocs . Bug fixes, enhancements. May-June 2020: Test suite for mkdocstrings itself. Better documentation. Maybe a second handler, just for the fun. Requirements \u00a4 mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 This project currently only works with the Material theme of MkDocs. Therefore, it is required that you have it installed. pip install mkdocs-material Installation \u00a4 With pip : python3.6 -m pip install mkdocstrings Usage \u00a4 # mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings : default_handler : python handlers : python : rendering : show_source : true watch : - src/my_library In one of your markdown files: # Reference :: : my_library.my_module.my_class rendering : show_source : false :: : org.jpackage.BestOfTheBestFactoryInterface handler : java # we don't have a java handler yet, it's just an example In documentation strings (written in Markdown), you can reference objects from other places: def some_function (): \"\"\" This is my function. It references [another function][package.submodule.function]. It also references another object directly: [package.submodule.SuperClass][]. \"\"\" pass Add some style in docs/custom.css : div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } And add it to your mkdocs.yml : extra_css : - custom.css","title":"Overview"},{"location":"#mkdocstrings","text":"Automatic documentation from sources, for MkDocs. Features Python handler features Requirements Installation Usage","title":"mkdocstrings"},{"location":"#features","text":"Language agnostic: just like mkdocs , mkdocstrings is written in Python but is language-agnostic. It means you can use it for any language, as long as you implement a handler for it. Currently, we only have a Python handler . Maybe you'd like to contribute another one ? Multiple themes support: each handler can offer multiple themes. Currently, we only offer the Material theme for the Python handler. Cross-references to other objects: mkdocstrings makes it possible to reference other headings from your Markdown files with the classic Markdown syntax: [identifier][] or [title][identifier] . This feature is language agnostic as well: you can cross-reference any heading that appear in your Markdown pages. If the handler for a particular language renders headings for documented objects, you'll be able to reference them! Inline injection in Markdown: instead of generating Markdown files, mkdocstrings allows you to inject documentation anywhere in your Markdown contents. The syntax is simple: ::: identifier followed by a 4-spaces indented YAML block. The identifier and YAML configuration will be passed to the appropriate handler to collect and render documentation. Global and local configuration: each handler can be configured globally in mkdocs.yml , and locally for each \"autodoc\" instruction. Watch source code directories: you can tell mkdocstrings to add directories to be watched by mkdocs when serving the documentation, for auto-reload. Sane defaults: you should be able to just drop the plugin in your configuration and enjoy your auto-generated docs.","title":"Features"},{"location":"#python-handler-features","text":"Data collection from source code : collection of the object-tree and the docstrings is done by pytkdocs . The following features are possible thanks to it: Support for type annotations: pytkdocs collects your type annotations and mkdocstrings uses them to display parameters types or return types. Recursive documentation of Python objects: just use the module dotted-path as identifier, and you get the full module docs. You don't need to inject documentation for each class, function, etc. Support for documented attribute: attributes (variables) followed by a docstring (triple-quoted string) will be recognized by pytkdocs in modules, classes and even in __init__ methods. Support for objects properties: pytkdocs detects if a method is a staticmethod , a classmethod , etc., it also detects if a property is read-only or writable, and more! These properties will be displayed next to the object signature by mkdocstrings . Google-style sections support in docstrings: pytkdocs understands Arguments: , Raises: and Returns: sections, and returns structured data for mkdocstrings to render them. Admonition support in docstrings: blocks like Note: or Warning: will be transformed to their admonition equivalent. We do not support nested admonitions in docstrings! Every object has a TOC entry: we render a heading for each object, meaning mkdocs picks them into the Table of Contents, which is nicely display by the Material theme. Thanks to mkdocstrings cross-reference ability, you can even reference other objects within your docstrings, with the classic Markdown syntax: [this object][package.module.object] or directly with [package.module.object][] Source code display: mkdocstrings can add a collapsible div containing the highlighted source code of the Python object. To get an example of what is possible, check mkdocstrings ' own documentation , auto-generated from sources by itself of course, and the following GIF:","title":"Python handler features"},{"location":"#roadmap","text":"December-January 2020: Proof of Concept. January-March 2020: Refactor. March-April 2020: Test suite for pytkdocs . Bug fixes, enhancements. May-June 2020: Test suite for mkdocstrings itself. Better documentation. Maybe a second handler, just for the fun.","title":"Roadmap"},{"location":"#requirements","text":"mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 This project currently only works with the Material theme of MkDocs. Therefore, it is required that you have it installed. pip install mkdocs-material","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install mkdocstrings","title":"Installation"},{"location":"#usage","text":"# mkdocs.yml theme : name : \"material\" plugins : - search - mkdocstrings : default_handler : python handlers : python : rendering : show_source : true watch : - src/my_library In one of your markdown files: # Reference :: : my_library.my_module.my_class rendering : show_source : false :: : org.jpackage.BestOfTheBestFactoryInterface handler : java # we don't have a java handler yet, it's just an example In documentation strings (written in Markdown), you can reference objects from other places: def some_function (): \"\"\" This is my function. It references [another function][package.submodule.function]. It also references another object directly: [package.submodule.SuperClass][]. \"\"\" pass Add some style in docs/custom.css : div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } And add it to your mkdocs.yml : extra_css : - custom.css","title":"Usage"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . v0.11.3 - 2020-06-07 \u00a4 Compare with v0.11.2 Bug Fixes \u00a4 Support custom theme directory configuration ( 1243cf6 by Abhishek Thakur). References: #120 , #121 v0.11.2 - 2020-05-20 \u00a4 Compare with v0.11.1 Packaging \u00a4 Increase pytkdocs version range to accept v0.4.0 ( changelog ). v0.11.1 - 2020-05-14 \u00a4 Compare with v0.11.0 Bug Fixes \u00a4 Fix integration with mkdocs logging une bonne fois pour toute ( 3293cbf by Timoth\u00e9e Mazzucotelli). Discard setup commands stdout ( ea44cea by Timoth\u00e9e Mazzucotelli). References: #91 Use the proper python executable to start subprocesses ( 9fe3b39 by Reece Dunham). References: #91 , #103 v0.11.0 - 2020-04-23 \u00a4 Compare with v0.10.3 Bug Fixes \u00a4 Properly raise on errors (respect strict mode) ( 2097208 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Hook properly to MkDocs logging ( b23daed by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Features \u00a4 Add setup_commands option to python handler ( 599f8e5 by Ross Mechanic). Related issues/PRs: #89 , #90 Add option to allow overriding templates ( 7360021 by Mika\u00ebl Capelle). Related issues/PRs: #59 , #82 v0.10.3 - 2020-04-10 \u00a4 Compare with v0.10.2 Bug Fixes \u00a4 Handle site_url not being defined ( 9fb4a9b by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #77 Packaging \u00a4 This version increases the accepted range of versions for the pytkdocs dependency to >=0.2.0, <0.4.0 . The pytkdocs project just released version 0.3.0 which: adds support for complex markup in docstrings sections items descriptions adds support for different indentations in docstrings sections (tabulations or less/more than 4 spaces) fixes docstring parsing for arguments whose names start with * , like *args and **kwargs v0.10.2 - 2020-04-07 \u00a4 Compare with v0.10.1 Packaging \u00a4 This version increases the accepted range of versions for the pymdown-extensions dependency, as well as for the mkdocs-material development dependency. Indeed, both these projects recently released major versions 7 and 5 respectively. Users who wish to use these new versions will be able to. See issue #74 . v0.10.1 - 2020-04-03 \u00a4 Compare with v0.10.0 Bug Fixes \u00a4 Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68 v0.10.0 - 2020-03-27 \u00a4 Compare with v0.9.1 Features \u00a4 Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector . v0.9.1 - 2020-03-21 \u00a4 Compare with v0.9.0 Bug fixes \u00a4 Fix cross-references when deploying to GitHub pages ( 36f804b ). v0.9.0 - 2020-03-21 \u00a4 Compare with v0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users. Features \u00a4 Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting. Bug fixes \u00a4 Various fixes and better error handling. v0.8.0 - 2020-03-04 \u00a4 Compare with v0.7.2 Breaking Changes \u00a4 Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2. v0.7.2 - 2020-03-04 \u00a4 Compare with v0.7.1 Bug Fixes \u00a4 Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ). v0.7.1 - 2020-02-18 \u00a4 Compare with v0.7.0 Bug Fixes \u00a4 Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ). v0.7.0 - 2020-01-13 \u00a4 Compare with v0.6.1 Bug Fixes \u00a4 Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ). Code Refactoring \u00a4 Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ). Features \u00a4 Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ). v0.6.1 - 2020-01-02 \u00a4 Compare with v0.6.0 Bug Fixes \u00a4 Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ). Code Refactoring \u00a4 Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ). v0.6.0 - 2019-12-28 \u00a4 Compare with v0.5.0 Bug Fixes \u00a4 Fix GenericMeta import error on Python 3.7+ ( febf2b9 ). Code Refactoring \u00a4 More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ). v0.5.0 - 2019-12-22 \u00a4 Compare with v0.4.0 Features \u00a4 Use divs in HTML contents to ease styling ( 2a36a0e ). v0.4.0 - 2019-12-22 \u00a4 Compare with v0.3.0 Features \u00a4 Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ). v0.3.0 - 2019-12-21 \u00a4 Compare with v0.2.0 Features \u00a4 Allow object referencing in docstrings ( 2dd50c0 ). v0.2.0 - 2019-12-15 \u00a4 Compare with v0.1.0 Misc \u00a4 Refactor, features, etc. ( 111fa85 ). v0.1.0 - 2019-12-12 \u00a4 Compare with first commit Misc \u00a4 Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#v0113-2020-06-07","text":"Compare with v0.11.2","title":"v0.11.3 - 2020-06-07"},{"location":"changelog/#bug-fixes","text":"Support custom theme directory configuration ( 1243cf6 by Abhishek Thakur). References: #120 , #121","title":"Bug Fixes"},{"location":"changelog/#v0112-2020-05-20","text":"Compare with v0.11.1","title":"v0.11.2 - 2020-05-20"},{"location":"changelog/#packaging","text":"Increase pytkdocs version range to accept v0.4.0 ( changelog ).","title":"Packaging"},{"location":"changelog/#v0111-2020-05-14","text":"Compare with v0.11.0","title":"v0.11.1 - 2020-05-14"},{"location":"changelog/#bug-fixes_1","text":"Fix integration with mkdocs logging une bonne fois pour toute ( 3293cbf by Timoth\u00e9e Mazzucotelli). Discard setup commands stdout ( ea44cea by Timoth\u00e9e Mazzucotelli). References: #91 Use the proper python executable to start subprocesses ( 9fe3b39 by Reece Dunham). References: #91 , #103","title":"Bug Fixes"},{"location":"changelog/#v0110-2020-04-23","text":"Compare with v0.10.3","title":"v0.11.0 - 2020-04-23"},{"location":"changelog/#bug-fixes_2","text":"Properly raise on errors (respect strict mode) ( 2097208 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86 Hook properly to MkDocs logging ( b23daed by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #86","title":"Bug Fixes"},{"location":"changelog/#features","text":"Add setup_commands option to python handler ( 599f8e5 by Ross Mechanic). Related issues/PRs: #89 , #90 Add option to allow overriding templates ( 7360021 by Mika\u00ebl Capelle). Related issues/PRs: #59 , #82","title":"Features"},{"location":"changelog/#v0103-2020-04-10","text":"Compare with v0.10.2","title":"v0.10.3 - 2020-04-10"},{"location":"changelog/#bug-fixes_3","text":"Handle site_url not being defined ( 9fb4a9b by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #77","title":"Bug Fixes"},{"location":"changelog/#packaging_1","text":"This version increases the accepted range of versions for the pytkdocs dependency to >=0.2.0, <0.4.0 . The pytkdocs project just released version 0.3.0 which: adds support for complex markup in docstrings sections items descriptions adds support for different indentations in docstrings sections (tabulations or less/more than 4 spaces) fixes docstring parsing for arguments whose names start with * , like *args and **kwargs","title":"Packaging"},{"location":"changelog/#v0102-2020-04-07","text":"Compare with v0.10.1","title":"v0.10.2 - 2020-04-07"},{"location":"changelog/#packaging_2","text":"This version increases the accepted range of versions for the pymdown-extensions dependency, as well as for the mkdocs-material development dependency. Indeed, both these projects recently released major versions 7 and 5 respectively. Users who wish to use these new versions will be able to. See issue #74 .","title":"Packaging"},{"location":"changelog/#v0101-2020-04-03","text":"Compare with v0.10.0","title":"v0.10.1 - 2020-04-03"},{"location":"changelog/#bug-fixes_4","text":"Fix jinja2 error for jinja2 < 2.11 ( 387f970 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #67 , #72 Fix missing dependency pymdown-extensions ( 648b99d by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #66 Fix heading level of hidden toc entries ( 475cc62 by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #65 Fix rendering signatures containing keyword_only ( c6c5add by Timoth\u00e9e Mazzucotelli). Related issues/PRs: #68","title":"Bug Fixes"},{"location":"changelog/#v0100-2020-03-27","text":"Compare with v0.9.1","title":"v0.10.0 - 2020-03-27"},{"location":"changelog/#features_1","text":"Prepare for new pytkdocs version ( 336421a ). Add options filters and members to the Python collector to reflect the new pytkdocs options. See the default configuration of the Python collector .","title":"Features"},{"location":"changelog/#v091-2020-03-21","text":"Compare with v0.9.0","title":"v0.9.1 - 2020-03-21"},{"location":"changelog/#bug-fixes_5","text":"Fix cross-references when deploying to GitHub pages ( 36f804b ).","title":"Bug fixes"},{"location":"changelog/#v090-2020-03-21","text":"Compare with v0.8.0 This version is a big refactor. We will just list the new features without pointing to particular commits. The documentation rendering looks slightly different, and should be better than before. No identified breaking changes for end-users.","title":"v0.9.0 - 2020-03-21"},{"location":"changelog/#features_2","text":"Language agnostic: we moved the code responsible for loading Python documentation into a new project, pytkdocs , and implemented a \"handlers\" logic, effectively allowing to support any given language. Waiting for your handlers contributions ! Multiple themes support: handlers can offer templates for multiple mkdocs themes. Better cross-references: cross-references now not only work between documented objects (between all languages, given the objects' identifiers are unique), but also for every heading of your Markdown pages. Configuration options: the rendering of Python documentation can now be configured, (globally and locally thanks to the handlers system), check the docs! Also see the recommended CSS . Proper logging messages: mkdocstrings now logs debug, warning and error messages, useful when troubleshooting.","title":"Features"},{"location":"changelog/#bug-fixes_6","text":"Various fixes and better error handling.","title":"Bug fixes"},{"location":"changelog/#v080-2020-03-04","text":"Compare with v0.7.2","title":"v0.8.0 - 2020-03-04"},{"location":"changelog/#breaking-changes","text":"Be compatible with Mkdocs >= 1.1 ( 5a974a4 ). This is a breaking change as we're not compatible with versions of Mkdocs below 1.1 anymore. If you cannot upgrade Mkdocs to 1.1, pin mkdocstrings' version to 0.7.2.","title":"Breaking Changes"},{"location":"changelog/#v072-2020-03-04","text":"Compare with v0.7.1","title":"v0.7.2 - 2020-03-04"},{"location":"changelog/#bug-fixes_7","text":"Catch OSError when trying to get source lines ( 8e8d604 ). Do not render signature empty sentinel ( 16dfd73 ). Fix for nested classes and their attributes ( 7fef903 ). Fix relative_file_path method ( 52715ad ). Wrap file path in backticks to escape it ( 2525f39 ).","title":"Bug Fixes"},{"location":"changelog/#v071-2020-02-18","text":"Compare with v0.7.0","title":"v0.7.1 - 2020-02-18"},{"location":"changelog/#bug-fixes_8","text":"Replace literal slash with os.sep for Windows compatibility ( 70f9af5 ).","title":"Bug Fixes"},{"location":"changelog/#v070-2020-01-13","text":"Compare with v0.6.1","title":"v0.7.0 - 2020-01-13"},{"location":"changelog/#bug-fixes_9","text":"Don't mark args or kwargs as required ( 4049d6f ). Filter submodules ( 7b11095 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring","text":"Don't guess lang in generated docs ( db4f60a ). Render at HTML step with custom markdown converter ( 9b5a3e1 ).","title":"Code Refactoring"},{"location":"changelog/#features_3","text":"Change forward ref to ref, fix optional unions ( 2f0bfaa ). Discover package submodules ( 231062a ). Implement watched source code (hacks) ( 4a67953 ).","title":"Features"},{"location":"changelog/#v061-2020-01-02","text":"Compare with v0.6.0","title":"v0.6.1 - 2020-01-02"},{"location":"changelog/#bug-fixes_10","text":"Break docstring discarding loop if found ( 5a17fec ). Fix discarding docstring ( 143f7cb ). Fix getting annotation from nodes ( ecde72b ). Fix various things ( affbf06 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_1","text":"Break as soon as we find the same attr in a parent class while trying to discard the docstring ( 65d7908 ). Split Docstring.parse method to improve readability ( 2226e2d ).","title":"Code Refactoring"},{"location":"changelog/#v060-2019-12-28","text":"Compare with v0.5.0","title":"v0.6.0 - 2019-12-28"},{"location":"changelog/#bug-fixes_11","text":"Fix GenericMeta import error on Python 3.7+ ( febf2b9 ).","title":"Bug Fixes"},{"location":"changelog/#code-refactoring_2","text":"More classes. Still ugly code though :'( ( f41c119 ). Split into more modules ( f1872a4 ). Use Object subclasses ( 40dd106 ).","title":"Code Refactoring"},{"location":"changelog/#v050-2019-12-22","text":"Compare with v0.4.0","title":"v0.5.0 - 2019-12-22"},{"location":"changelog/#features_4","text":"Use divs in HTML contents to ease styling ( 2a36a0e ).","title":"Features"},{"location":"changelog/#v040-2019-12-22","text":"Compare with v0.3.0","title":"v0.4.0 - 2019-12-22"},{"location":"changelog/#features_5","text":"Parse docstrings Google-style blocks, get types from signature ( 5af0c7b ).","title":"Features"},{"location":"changelog/#v030-2019-12-21","text":"Compare with v0.2.0","title":"v0.3.0 - 2019-12-21"},{"location":"changelog/#features_6","text":"Allow object referencing in docstrings ( 2dd50c0 ).","title":"Features"},{"location":"changelog/#v020-2019-12-15","text":"Compare with v0.1.0","title":"v0.2.0 - 2019-12-15"},{"location":"changelog/#misc","text":"Refactor, features, etc. ( 111fa85 ).","title":"Misc"},{"location":"changelog/#v010-2019-12-12","text":"Compare with first commit","title":"v0.1.0 - 2019-12-12"},{"location":"changelog/#misc_1","text":"Clean up (delete unused files) ( c227043 ). Clean up unused makefile rules ( edc01e9 ). Initial commit ( f1dd8fb ). Update readme ( ae56bdd ). Add plugin ( 6ed5cb1 ). First PoC, needs better theming ( 18a00b9 ). Get attributes docstrings ( 7838fff ). Refactor ( f68f1a8 ).","title":"Misc"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd mkdocstrings make setup That's it! You now have the dependencies installed. Run make help to see all the available actions! Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd mkdocstrings make setup That's it! You now have the dependencies installed. Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation If you updated the documentation or the project dependencies: run make docs-regen run make docs-serve , go to http://localhost:8000 and check that everything looks good Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"Credits \u00a4 These projects were used to build mkdocstrings . Thank you! python | poetry | copier-poetry Direct dependencies \u00a4 bandit | beautifulsoup4 | black | coverage | failprint | flake8 | flake8-bandit | flake8-black | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-isort | flake8-tidy-imports | flake8-variables-names | git-changelog | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mypy | pymdown-extensions | pytest | pytest-cov | pytest-sugar | pytest-xdist | pytkdocs | requests | toml Indirect dependencies \u00a4 ansimarkup | apipkg | appdirs | appnope | atomicwrites | attrs | backcall | certifi | chardet | click | colorama | decorator | execnet | flake8-polyfill | future | gitdb | GitPython | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | joblib | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pyparsing | pytest-forked | PyYAML | regex | six | smmap | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build mkdocstrings . Thank you! python | poetry | copier-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"bandit | beautifulsoup4 | black | coverage | failprint | flake8 | flake8-bandit | flake8-black | flake8-builtins | flake8-comprehensions | flake8-docstrings | flake8-isort | flake8-tidy-imports | flake8-variables-names | git-changelog | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | mypy | pymdown-extensions | pytest | pytest-cov | pytest-sugar | pytest-xdist | pytkdocs | requests | toml","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"ansimarkup | apipkg | appdirs | appnope | atomicwrites | attrs | backcall | certifi | chardet | click | colorama | decorator | execnet | flake8-polyfill | future | gitdb | GitPython | idna | importlib-metadata | ipython-genutils | jedi | Jinja2 | joblib | livereload | lunr | Markdown | MarkupSafe | mccabe | mkdocs-material-extensions | more-itertools | mypy-extensions | nltk | packaging | parso | pathspec | pbr | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pydocstyle | pyflakes | Pygments | pyparsing | pytest-forked | PyYAML | regex | six | smmap | snowballstemmer | soupsieve | stevedore | termcolor | testfixtures | tornado | tqdm | traitlets | typed-ast | typing-extensions | urllib3 | wcwidth | zipp More credits from the author","title":"Indirect dependencies"},{"location":"license/","text":"ISC License Copyright (c) 2019, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"troubleshooting/","text":"Troubleshooting \u00a4 Code blocks in admonitions (in docstrings or else) are not rendered correctly \u00a4 To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences MkDocs warns me about links to unfound documentation files \u00a4 A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] . Nothing is rendered at all \u00a4 Python? \"No\": we only support Python right now. \"Yes\": is your package available in the Python path? If not, install it in your current virtualenv and try again. Make sure you don't have an old version of your package installed, shadowing your source code. Some objects are not rendered (they do not appear in the generated docs) \u00a4 Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the docstring format page. Check the output of the mkdocs command, and re-run it with -v if necessary. Warnings should appear, showing errors that happened during collection. The generated documentation does not look good \u00a4 Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts. Warning: could not find cross-reference target \u00a4 Make sure you have defined site_url in mkdocs.yml , as it is required for cross-references when building the site (the error does not happen when serving because then site_url is auto-populated by mkdocs ). Make sure the referenced object was both collected and rendered: verify your selection and rendering options. For false-positives, you can wrap the text in backticks (`) to prevent mkdocstrings from trying to process it. WindowsPath object is not iterable \u00a4 If you get a traceback like this one: ... File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\python.py\", line 244, in get_handler return PythonHandler(collector=PythonCollector(), renderer=PythonRenderer(\"python\", theme)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\__init__.py\", line 124, in __init__ self.env = Environment(autoescape=True, loader=FileSystemLoader(theme_dir)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\jinja2\\loaders.py\", line 163, in __init__ self.searchpath = list(searchpath) TypeError: 'WindowsPath' object is not iterable Try upgrading your installed version of Jinja2: pip install -U jinja2 Version 2.11.1 seems to be working fine. Python specifics \u00a4 LaTeX in docstrings is not rendered correctly \u00a4 If you are using a Markdown extension like markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\" My docstrings in comments ( #: ) are not picked up \u00a4 It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. Write: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\" It does not look better, I know, but this is the price to pay. My wrapped function shows documentation/code for its wrapper instead of its own \u00a4 Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#code-blocks-in-admonitions-in-docstrings-or-else-are-not-rendered-correctly","text":"To render code blocks in admonitions, you need to add the pymdownx.superfences extensions to the list of Markdown extensions in mkdocs.yml . For example: !!! note Some text. ```bash echo \"some code\" ``` # mkdocs.yml markdown_extensions : - admonition - codehilite - pymdownx.superfences","title":"Code blocks in admonitions (in docstrings or else) are not rendered correctly"},{"location":"troubleshooting/#mkdocs-warns-me-about-links-to-unfound-documentation-files","text":"A warning like this one: WARNING - Documentation file 'reference/parsers/docstrings.md' contains a link to 'reference/parsers/pytkdocs.parsers.docstrings.Section' which is not found in the documentation files. ...generally means you used parentheses () instead of brackets [] for a cross-reference. Notice the dots in reference/parsers/pytkdocs.parsers.docstrings.Section ? It shows that it's probably a cross-reference, not a direct link. It's probably written like [Section](pytkdocs.parsers.docstrings.Section) in the docs, when it should be [Section][pytkdocs.parsers.docstrings.Section] .","title":"MkDocs warns me about links to unfound documentation files"},{"location":"troubleshooting/#nothing-is-rendered-at-all","text":"Python? \"No\": we only support Python right now. \"Yes\": is your package available in the Python path? If not, install it in your current virtualenv and try again. Make sure you don't have an old version of your package installed, shadowing your source code.","title":"Nothing is rendered at all"},{"location":"troubleshooting/#some-objects-are-not-rendered-they-do-not-appear-in-the-generated-docs","text":"Make sure the configuration options of the handler for both selection and rendering are correct. Check the documentation for Handlers to see the available options for each handler. Also make sure your documentation in your source code is formatted correctly. For Python code, check the docstring format page. Check the output of the mkdocs command, and re-run it with -v if necessary. Warnings should appear, showing errors that happened during collection.","title":"Some objects are not rendered (they do not appear in the generated docs)"},{"location":"troubleshooting/#the-generated-documentation-does-not-look-good","text":"Are you using the Material theme? \"No\": We do not support any other theme yet. Check the bugtracker to see if there is a feature request asking to support your theme. If you find one, vote with a thumbs up. If not, you can open a ticket. \"Yes\": Please open an ticket on the bugtracker with a detailed explanation and screenshots of the bad-looking parts.","title":"The generated documentation does not look good"},{"location":"troubleshooting/#warning-could-not-find-cross-reference-target","text":"Make sure you have defined site_url in mkdocs.yml , as it is required for cross-references when building the site (the error does not happen when serving because then site_url is auto-populated by mkdocs ). Make sure the referenced object was both collected and rendered: verify your selection and rendering options. For false-positives, you can wrap the text in backticks (`) to prevent mkdocstrings from trying to process it.","title":"Warning: could not find cross-reference target"},{"location":"troubleshooting/#windowspath-object-is-not-iterable","text":"If you get a traceback like this one: ... File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\python.py\", line 244, in get_handler return PythonHandler(collector=PythonCollector(), renderer=PythonRenderer(\"python\", theme)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\mkdocstrings\\handlers\\__init__.py\", line 124, in __init__ self.env = Environment(autoescape=True, loader=FileSystemLoader(theme_dir)) File \"c:\\users\\me\\appdata\\local\\continuum\\anaconda3\\lib\\site-packages\\jinja2\\loaders.py\", line 163, in __init__ self.searchpath = list(searchpath) TypeError: 'WindowsPath' object is not iterable Try upgrading your installed version of Jinja2: pip install -U jinja2 Version 2.11.1 seems to be working fine.","title":"WindowsPath object is not iterable"},{"location":"troubleshooting/#python-specifics","text":"","title":"Python specifics"},{"location":"troubleshooting/#latex-in-docstrings-is-not-rendered-correctly","text":"If you are using a Markdown extension like markdown-katex to render LaTeX, add r in front of your docstring to make sure nothing is escaped. You'll still maybe have to play with escaping to get things right. Example: def math_function ( x , y ): r \"\"\" Look at these formulas: ```math f(x) = \\int_{-\\infty}^\\infty \\hat f(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi ``` \"\"\"","title":"LaTeX in docstrings is not rendered correctly"},{"location":"troubleshooting/#my-docstrings-in-comments-are-not-picked-up","text":"It's because pytkdocs does not pick up documentation in comments. To load documentation for modules, classes, methods and functions, it uses inspect . To load documentation for attributes, it uses ast to parse the source code, searching for pairs of nodes like assignment - string , and ast does not parse comments. So instead of: import enum class MyEnum ( enum . Enum ): v1 = 1 #: The first choice. v2 = 2 #: The second choice. Write: import enum class MyEnum ( enum . Enum ): v1 = 1 \"\"\"The first choice.\"\"\" v2 = 2 \"\"\"The second choice.\"\"\" It does not look better, I know, but this is the price to pay.","title":"My docstrings in comments (#:) are not picked up"},{"location":"troubleshooting/#my-wrapped-function-shows-documentationcode-for-its-wrapper-instead-of-its-own","text":"Use functools.wraps() : from functools import wraps def my_decorator ( function ): \"\"\"The decorator docs.\"\"\" @wraps ( function ) def wrapped_function ( * args , ** kwargs ): print ( \"hello\" ) function ( * args , ** kwargs ) print ( \"bye\" ) return wrapped_function @my_decorator def my_function ( * args , ** kwargs ): \"\"\"The function docs.\"\"\" print ( * args , ** kwargs )","title":"My wrapped function shows documentation/code for its wrapper instead of its own"},{"location":"handlers/overview/","text":"Handlers \u00a4 A handler is what makes it possible to collect and render documentation for a particular language. It is composed of a collector and a renderer. See the documentation for [ BaseHandler ][mkdocstrings.handlers.BaseHandler], [ BaseCollector ][mkdocstrings.handlers.BaseCollector] and [ BaseRenderer ][mkdocstrings.handlers.BaseRenderer]. Available handlers \u00a4 [Python][mkdocstrings.handlers.python]","title":"Overview"},{"location":"handlers/overview/#handlers","text":"A handler is what makes it possible to collect and render documentation for a particular language. It is composed of a collector and a renderer. See the documentation for [ BaseHandler ][mkdocstrings.handlers.BaseHandler], [ BaseCollector ][mkdocstrings.handlers.BaseCollector] and [ BaseRenderer ][mkdocstrings.handlers.BaseRenderer].","title":"Handlers"},{"location":"handlers/overview/#available-handlers","text":"[Python][mkdocstrings.handlers.python]","title":"Available handlers"},{"location":"handlers/python/","text":"Documentation collection \u00a4 This page is a work in progress. Docstrings format \u00a4 Your docstrings must follow a particular format, otherwise mkdocstrings will throw an exception. This will be improved to be more robust over time. from typing import Optional def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\" A short description of this function. A longer description of this function. You can use more lines. This is a code block, as usual. ```python s = \"This is a Python code block :)\" ``` Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines with at least two more spaces. They will all be concatenated in one line, so do not try to use complex markup here. Note: We omitted the type hints next to the parameters names. Usually you would write something like `param1 (int): ...`, but `mkdocstrings` gets the type information from the signature, so it's not needed here. Exceptions are written the same. Raises: OSError: Explain when this error is thrown. RuntimeError: Explain as well. Multi-line description, etc. Let's see the return value section now. Returns: A description of the value that is returned. Again multiple lines are allowed. They will also be concatenated to one line, so do not use complex markup here. Note: Other words are supported: - `Args`, `Arguments`, `Params` and `Parameters` for the parameters. - `Raise`, `Raises`, `Except`, and `Exceptions` for exceptions. - `Return` or `Returns` for return value. They are all case-insensitive, so you can write `RETURNS:` or `params:`. \"\"\" return f \" { param2 }{ param1 } \" Recommended style \u00a4 /* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } /* Don't capitalize names. */ h5 . doc-heading { text-transform : none !important ; } /* Don't use vertical space on hidden ToC entries. */ h6 . hidden-toc { margin : 0 !important ; position : relative ; top : -70 px ; } h6 . hidden-toc :: before { margin-top : 0 !important ; padding-top : 0 !important ; } /* Don't show permalink of hidden ToC entries. */ h6 . hidden-toc a . headerlink { display : none ; } /* Avoid breaking parameters name, etc. in table cells. */ td code { word-break : normal !important ; } /* For pieces of Markdown rendered in table cells. */ td p { margin-top : 0 !important ; margin-bottom : 0 !important ; }","title":"Python"},{"location":"handlers/python/#documentation-collection","text":"This page is a work in progress.","title":"Documentation collection"},{"location":"handlers/python/#docstrings-format","text":"Your docstrings must follow a particular format, otherwise mkdocstrings will throw an exception. This will be improved to be more robust over time. from typing import Optional def my_function ( param1 : int , param2 : Optional [ str ] = None ) -> str : \"\"\" A short description of this function. A longer description of this function. You can use more lines. This is a code block, as usual. ```python s = \"This is a Python code block :)\" ``` Arguments: param1: An integer? param2: A string? If you have a long description, you can split it on multiple lines. Just remember to indent those lines with at least two more spaces. They will all be concatenated in one line, so do not try to use complex markup here. Note: We omitted the type hints next to the parameters names. Usually you would write something like `param1 (int): ...`, but `mkdocstrings` gets the type information from the signature, so it's not needed here. Exceptions are written the same. Raises: OSError: Explain when this error is thrown. RuntimeError: Explain as well. Multi-line description, etc. Let's see the return value section now. Returns: A description of the value that is returned. Again multiple lines are allowed. They will also be concatenated to one line, so do not use complex markup here. Note: Other words are supported: - `Args`, `Arguments`, `Params` and `Parameters` for the parameters. - `Raise`, `Raises`, `Except`, and `Exceptions` for exceptions. - `Return` or `Returns` for return value. They are all case-insensitive, so you can write `RETURNS:` or `params:`. \"\"\" return f \" { param2 }{ param1 } \"","title":"Docstrings format"},{"location":"handlers/python/#recommended-style","text":"/* Indentation. */ div . doc-contents : not ( . first ) { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); margin-bottom : 80 px ; } /* Don't capitalize names. */ h5 . doc-heading { text-transform : none !important ; } /* Don't use vertical space on hidden ToC entries. */ h6 . hidden-toc { margin : 0 !important ; position : relative ; top : -70 px ; } h6 . hidden-toc :: before { margin-top : 0 !important ; padding-top : 0 !important ; } /* Don't show permalink of hidden ToC entries. */ h6 . hidden-toc a . headerlink { display : none ; } /* Avoid breaking parameters name, etc. in table cells. */ td code { word-break : normal !important ; } /* For pieces of Markdown rendered in table cells. */ td p { margin-top : 0 !important ; margin-bottom : 0 !important ; }","title":"Recommended style"},{"location":"reference/extension/","text":"\u00a4 This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a [handler][mkdocstrings.handlers.BaseHandler] to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc AutoDocProcessor \u00a4 Our \"autodoc\" Markdown block processor. It has a [ test method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [ run method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block. __init__ ( self , parser , md , config ) special \u00a4 Initialization method. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the mkdocstrings plugin. required Source code in mkdocstrings/extension.py 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , parser : BlockParser , md : Markdown , config : dict ) -> None : \"\"\" Initialization method. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config get_handler_config ( self , handler_name ) \u00a4 Return the global configuration of the given handler. Parameters: Name Type Description Default handler_name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in mkdocstrings/extension.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def get_handler_config ( self , handler_name : str ) -> dict : \"\"\" Return the global configuration of the given handler. Arguments: handler_name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( handler_name , {}) return {} get_handler_name ( self , config ) \u00a4 Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in mkdocstrings/extension.py 196 197 198 199 200 201 202 203 204 205 206 207 208 def get_handler_name ( self , config : dict ) -> str : \"\"\" Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Args: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" if \"handler\" in config : return config [ \"handler\" ] return self . _config [ \"mkdocstrings\" ][ \"default_handler\" ] get_item_configs ( handler_config , config ) staticmethod \u00a4 Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_config dict The global configuration of a handler. It can be an empty dictionary. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple[dict, dict] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 @staticmethod def get_item_configs ( handler_config : dict , config : dict ) -> Tuple [ dict , dict ]: \"\"\" Get the selection and rendering configuration merged into the global configuration of the given handler. Args: handler_config: The global configuration of a handler. It can be an empty dictionary. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" item_selection_config = dict ( handler_config . get ( \"selection\" , {})) item_selection_config . update ( config . get ( \"selection\" , {})) item_rendering_config = dict ( handler_config . get ( \"rendering\" , {})) item_rendering_config . update ( config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config run ( self , parent , blocks ) \u00a4 The processing of autodoc instructions is done here. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks Element The rest of the blocks to be processed. required Source code in mkdocstrings/extension.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def run ( self , parent : Element , blocks : Element ) -> None : \"\"\" The processing of autodoc instructions is done here. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . RE . search ( str ( block )) if match : # removes the first line block = block [ match . end () :] # type: ignore block , the_rest = self . detab ( block ) if match : identifier = match . group ( 1 ) log . debug ( f \"mkdocstrings.extension: Matched '::: { identifier } '\" ) config = yaml . safe_load ( str ( block )) or {} handler_name = self . get_handler_name ( config ) log . debug ( f \"mkdocstrings.extension: Using handler ' { handler_name } '\" ) handler_config = self . get_handler_config ( handler_name ) handler = get_handler ( handler_name , self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) selection , rendering = self . get_item_configs ( handler_config , config ) log . debug ( \"mkdocstrings.extension: Collecting data\" ) try : data : Any = handler . collector . collect ( identifier , selection ) except CollectionError : log . error ( f \"mkdocstrings.extension: Could not collect ' { identifier } '\" ) raise log . debug ( \"mkdocstrings.extension: Updating renderer's env\" ) handler . renderer . update_env ( self . md , self . _config ) log . debug ( \"mkdocstrings.extension: Rendering templates\" ) try : rendered = handler . renderer . render ( data , rendering ) except TemplateNotFound as error : theme_name = self . _config [ \"theme_name\" ] log . error ( f \"mkdocstrings.extension: Template ' { error . name } ' not found \" f \"for ' { handler_name } ' handler and theme ' { theme_name } '.\" ) raise log . debug ( \"mkdocstrings.extension: Loading HTML back into XML tree\" ) try : as_xml = XML ( rendered ) except ParseError as error : message = f \"mkdocstrings.extension: { error } \" if \"mismatched tag\" in str ( error ): line , column = str ( error ) . split ( \":\" )[ - 1 ] . split ( \", \" ) lineno = int ( line . split ( \" \" )[ - 1 ]) columnno = int ( column . split ( \" \" )[ - 1 ]) line = rendered . split ( \" \\n \" )[ lineno - 1 ] character = line [ columnno ] message += ( f \" (character { character } ): \\n { line } \\n \" f \"If your Markdown contains angle brackets < >, try to wrap them between backticks `< >`, \" f \"or replace them with < and >\" ) log . error ( message ) raise as_xml = atomic_brute_cast ( as_xml ) # type: ignore parent . append ( as_xml ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest ) test ( self , parent , block ) \u00a4 Match our autodoc instructions. Source code in mkdocstrings/extension.py 97 98 99 100 101 102 103 104 105 106 def test ( self , parent : Element , block : Element ) -> bool : \"\"\"Match our autodoc instructions.\"\"\" sibling = self . lastChild ( parent ) bool1 = self . RE . search ( str ( block )) bool2 = ( str ( block ) . startswith ( \" \" * self . tab_length ) and sibling is not None and sibling . get ( \"class\" , \"\" ) . find ( self . CLASSNAME ) != - 1 ) return bool ( bool1 or bool2 ) MkdocstringsExtension \u00a4 Our Markdown extension. It cannot work outside of mkdocstrings . __init__ ( self , config , ** kwargs ) special \u00a4 Initialization method. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in [ extendMarkdown ][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. required kwargs Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py 251 252 253 254 255 256 257 258 259 260 261 def __init__ ( self , config : dict , ** kwargs ) -> None : \"\"\" Initialization method. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config extendMarkdown ( self , md ) \u00a4 Register the extension. Add an instance of our [ AutoDocProcessor ][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py 263 264 265 266 267 268 269 270 271 272 273 274 def extendMarkdown ( self , md : Markdown ) -> None : \"\"\" Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Args: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) processor = AutoDocProcessor ( md . parser , md , self . _config ) md . parser . blockprocessors . register ( processor , \"mkdocstrings\" , 110 ) atomic_brute_cast ( tree ) \u00a4 Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue Python-Markdown/markdown#920 . On a side note: isn't atomic_brute_cast such a beautiful function name? Parameters: Name Type Description Default tree Element An XML node, used like the root of an XML tree. required Returns: Type Description Element The same node, recursively modified by side-effect. You can skip re-assigning the return value. Source code in mkdocstrings/extension.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def atomic_brute_cast ( tree : Element ) -> Element : \"\"\" Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue [Python-Markdown/markdown#920](https://github.com/Python-Markdown/markdown/issues/920). On a side note: isn't `atomic_brute_cast` such a beautiful function name? Arguments: tree: An XML node, used like the root of an XML tree. Returns: The same node, recursively modified by side-effect. You can skip re-assigning the return value. \"\"\" if tree . text : tree . text = AtomicString ( tree . text ) for child in tree : atomic_brute_cast ( child ) return tree","title":"extension.py"},{"location":"reference/extension/#mkdocstrings.extension","text":"This module holds the code of the Markdown extension responsible for matching \"autodoc\" instructions. The extension is composed of a Markdown block processor that matches indented blocks starting with a line like '::: identifier'. For each of these blocks, it uses a [handler][mkdocstrings.handlers.BaseHandler] to collect documentation about the given identifier and render it with Jinja templates. Both the collection and rendering process can be configured by adding YAML configuration under the \"autodoc\" instruction: :: : some.identifier handler : python selection : option1 : value1 option2 : - value2a - value2b rendering : option_x : etc","title":"mkdocstrings.extension"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor","text":"Our \"autodoc\" Markdown block processor. It has a [ test method][mkdocstrings.extension.AutoDocProcessor.test] that tells if a block matches a criterion, and a [ run method][mkdocstrings.extension.AutoDocProcessor.run] that processes it. It also has utility methods allowing to get handlers and their configuration easily, useful when processing a matched block.","title":"AutoDocProcessor"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.__init__","text":"Initialization method. Parameters: Name Type Description Default parser BlockParser A markdown.blockparser.BlockParser instance. required md Markdown A markdown.Markdown instance. required config dict The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the mkdocstrings plugin. required Source code in mkdocstrings/extension.py 83 84 85 86 87 88 89 90 91 92 93 94 95 def __init__ ( self , parser : BlockParser , md : Markdown , config : dict ) -> None : \"\"\" Initialization method. Arguments: parser: A `markdown.blockparser.BlockParser` instance. md: A `markdown.Markdown` instance. config: The [configuration][mkdocstrings.plugin.MkdocstringsPlugin.config_scheme] of the `mkdocstrings` plugin. \"\"\" super () . __init__ ( parser = parser ) self . md = md self . _config = config","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.get_handler_config","text":"Return the global configuration of the given handler. Parameters: Name Type Description Default handler_name str The name of the handler to get the global configuration of. required Returns: Type Description dict The global configuration of the given handler. It can be an empty dictionary. Source code in mkdocstrings/extension.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 def get_handler_config ( self , handler_name : str ) -> dict : \"\"\" Return the global configuration of the given handler. Arguments: handler_name: The name of the handler to get the global configuration of. Returns: The global configuration of the given handler. It can be an empty dictionary. \"\"\" handlers = self . _config [ \"mkdocstrings\" ] . get ( \"handlers\" , {}) if handlers : return handlers . get ( handler_name , {}) return {}","title":"get_handler_config()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.get_handler_name","text":"Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Parameters: Name Type Description Default config dict A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. required Returns: Type Description str The name of the handler to use. Source code in mkdocstrings/extension.py 196 197 198 199 200 201 202 203 204 205 206 207 208 def get_handler_name ( self , config : dict ) -> str : \"\"\" Return the handler name defined in an \"autodoc\" instruction YAML configuration, or the global default handler. Args: config: A configuration dictionary, obtained from YAML below the \"autodoc\" instruction. Returns: The name of the handler to use. \"\"\" if \"handler\" in config : return config [ \"handler\" ] return self . _config [ \"mkdocstrings\" ][ \"default_handler\" ]","title":"get_handler_name()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.get_item_configs","text":"Get the selection and rendering configuration merged into the global configuration of the given handler. Parameters: Name Type Description Default handler_config dict The global configuration of a handler. It can be an empty dictionary. required config dict The configuration to merge into the global handler configuration. required Returns: Type Description Tuple[dict, dict] Two dictionaries: selection and rendering. The local configurations are merged into the global ones. Source code in mkdocstrings/extension.py 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 @staticmethod def get_item_configs ( handler_config : dict , config : dict ) -> Tuple [ dict , dict ]: \"\"\" Get the selection and rendering configuration merged into the global configuration of the given handler. Args: handler_config: The global configuration of a handler. It can be an empty dictionary. config: The configuration to merge into the global handler configuration. Returns: Two dictionaries: selection and rendering. The local configurations are merged into the global ones. \"\"\" item_selection_config = dict ( handler_config . get ( \"selection\" , {})) item_selection_config . update ( config . get ( \"selection\" , {})) item_rendering_config = dict ( handler_config . get ( \"rendering\" , {})) item_rendering_config . update ( config . get ( \"rendering\" , {})) return item_selection_config , item_rendering_config","title":"get_item_configs()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.run","text":"The processing of autodoc instructions is done here. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Parameters: Name Type Description Default parent Element The parent element in the XML tree. required blocks Element The rest of the blocks to be processed. required Source code in mkdocstrings/extension.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 def run ( self , parent : Element , blocks : Element ) -> None : \"\"\" The processing of autodoc instructions is done here. The identifier and configuration lines are retrieved from a matched block and used to collect and render an object. Arguments: parent: The parent element in the XML tree. blocks: The rest of the blocks to be processed. \"\"\" block = blocks . pop ( 0 ) match = self . RE . search ( str ( block )) if match : # removes the first line block = block [ match . end () :] # type: ignore block , the_rest = self . detab ( block ) if match : identifier = match . group ( 1 ) log . debug ( f \"mkdocstrings.extension: Matched '::: { identifier } '\" ) config = yaml . safe_load ( str ( block )) or {} handler_name = self . get_handler_name ( config ) log . debug ( f \"mkdocstrings.extension: Using handler ' { handler_name } '\" ) handler_config = self . get_handler_config ( handler_name ) handler = get_handler ( handler_name , self . _config [ \"theme_name\" ], self . _config [ \"mkdocstrings\" ][ \"custom_templates\" ], ** handler_config , ) selection , rendering = self . get_item_configs ( handler_config , config ) log . debug ( \"mkdocstrings.extension: Collecting data\" ) try : data : Any = handler . collector . collect ( identifier , selection ) except CollectionError : log . error ( f \"mkdocstrings.extension: Could not collect ' { identifier } '\" ) raise log . debug ( \"mkdocstrings.extension: Updating renderer's env\" ) handler . renderer . update_env ( self . md , self . _config ) log . debug ( \"mkdocstrings.extension: Rendering templates\" ) try : rendered = handler . renderer . render ( data , rendering ) except TemplateNotFound as error : theme_name = self . _config [ \"theme_name\" ] log . error ( f \"mkdocstrings.extension: Template ' { error . name } ' not found \" f \"for ' { handler_name } ' handler and theme ' { theme_name } '.\" ) raise log . debug ( \"mkdocstrings.extension: Loading HTML back into XML tree\" ) try : as_xml = XML ( rendered ) except ParseError as error : message = f \"mkdocstrings.extension: { error } \" if \"mismatched tag\" in str ( error ): line , column = str ( error ) . split ( \":\" )[ - 1 ] . split ( \", \" ) lineno = int ( line . split ( \" \" )[ - 1 ]) columnno = int ( column . split ( \" \" )[ - 1 ]) line = rendered . split ( \" \\n \" )[ lineno - 1 ] character = line [ columnno ] message += ( f \" (character { character } ): \\n { line } \\n \" f \"If your Markdown contains angle brackets < >, try to wrap them between backticks `< >`, \" f \"or replace them with < and >\" ) log . error ( message ) raise as_xml = atomic_brute_cast ( as_xml ) # type: ignore parent . append ( as_xml ) if the_rest : # This block contained unindented line(s) after the first indented # line. Insert these lines as the first block of the master blocks # list for future processing. blocks . insert ( 0 , the_rest )","title":"run()"},{"location":"reference/extension/#mkdocstrings.extension.AutoDocProcessor.test","text":"Match our autodoc instructions. Source code in mkdocstrings/extension.py 97 98 99 100 101 102 103 104 105 106 def test ( self , parent : Element , block : Element ) -> bool : \"\"\"Match our autodoc instructions.\"\"\" sibling = self . lastChild ( parent ) bool1 = self . RE . search ( str ( block )) bool2 = ( str ( block ) . startswith ( \" \" * self . tab_length ) and sibling is not None and sibling . get ( \"class\" , \"\" ) . find ( self . CLASSNAME ) != - 1 ) return bool ( bool1 or bool2 )","title":"test()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension","text":"Our Markdown extension. It cannot work outside of mkdocstrings .","title":"MkdocstringsExtension"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.__init__","text":"Initialization method. Parameters: Name Type Description Default config dict The configuration items from mkdocs and mkdocstrings that must be passed to the block processor when instantiated in [ extendMarkdown ][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. required kwargs Keyword arguments used by markdown.extensions.Extension . {} Source code in mkdocstrings/extension.py 251 252 253 254 255 256 257 258 259 260 261 def __init__ ( self , config : dict , ** kwargs ) -> None : \"\"\" Initialization method. Arguments: config: The configuration items from `mkdocs` and `mkdocstrings` that must be passed to the block processor when instantiated in [`extendMarkdown`][mkdocstrings.extension.MkdocstringsExtension.extendMarkdown]. kwargs: Keyword arguments used by `markdown.extensions.Extension`. \"\"\" super () . __init__ ( ** kwargs ) self . _config = config","title":"__init__()"},{"location":"reference/extension/#mkdocstrings.extension.MkdocstringsExtension.extendMarkdown","text":"Register the extension. Add an instance of our [ AutoDocProcessor ][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Parameters: Name Type Description Default md Markdown A markdown.Markdown instance. required Source code in mkdocstrings/extension.py 263 264 265 266 267 268 269 270 271 272 273 274 def extendMarkdown ( self , md : Markdown ) -> None : \"\"\" Register the extension. Add an instance of our [`AutoDocProcessor`][mkdocstrings.extension.AutoDocProcessor] to the Markdown parser. Args: md: A `markdown.Markdown` instance. \"\"\" md . registerExtension ( self ) processor = AutoDocProcessor ( md . parser , md , self . _config ) md . parser . blockprocessors . register ( processor , \"mkdocstrings\" , 110 )","title":"extendMarkdown()"},{"location":"reference/extension/#mkdocstrings.extension.atomic_brute_cast","text":"Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue Python-Markdown/markdown#920 . On a side note: isn't atomic_brute_cast such a beautiful function name? Parameters: Name Type Description Default tree Element An XML node, used like the root of an XML tree. required Returns: Type Description Element The same node, recursively modified by side-effect. You can skip re-assigning the return value. Source code in mkdocstrings/extension.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def atomic_brute_cast ( tree : Element ) -> Element : \"\"\" Cast every node's text into an atomic string to prevent further processing on it. Since we generate the final HTML with Jinja templates, we do not want other inline or tree processors to keep modifying the data, so this function is used to mark the complete tree as \"do not touch\". Reference: issue [Python-Markdown/markdown#920](https://github.com/Python-Markdown/markdown/issues/920). On a side note: isn't `atomic_brute_cast` such a beautiful function name? Arguments: tree: An XML node, used like the root of an XML tree. Returns: The same node, recursively modified by side-effect. You can skip re-assigning the return value. \"\"\" if tree . text : tree . text = AtomicString ( tree . text ) for child in tree : atomic_brute_cast ( child ) return tree","title":"atomic_brute_cast()"},{"location":"reference/plugin/","text":"\u00a4 This module contains the mkdocs plugin. The plugin instantiates a Markdown extension ([ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension]), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_contents event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. Once the documentation is built, the on_post_build event hook is triggered and calls the [ handlers.teardown() method][mkdocstrings.handlers.teardown]. This method is used to teardown the [handlers][mkdocstrings.handlers] that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook . AUTO_REF: Pattern \u00a4 A regular expression to match unresolved Markdown references in the [ on_post_page hook][mkdocstrings.plugin.MkdocstringsPlugin.on_post_page]. RENDERING_OPTS_KEY: str \u00a4 The name of the rendering parameter in YAML configuration blocks. SELECTION_OPTS_KEY: str \u00a4 The name of the selection parameter in YAML configuration blocks. MkdocstringsPlugin \u00a4 An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_contents on_post_page on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system.. config_scheme: Tuple [ Tuple [ str , MkType ]] class-attribute \u00a4 The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" setup_commands : - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust : selection : selection_opt : 2 __init__ ( self ) special \u00a4 Initialization method. Source code in mkdocstrings/plugin.py 115 116 117 118 119 def __init__ ( self ) -> None : \"\"\"Initialization method.\"\"\" super ( MkdocstringsPlugin , self ) . __init__ () self . mkdocstrings_extension : Optional [ MkdocstringsExtension ] = None self . url_map : Dict [ Any , str ] = {} fix_ref ( self , unmapped , unintended ) \u00a4 Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we append the identifier to the outer unintended list to tell the caller that this unresolved reference should be ignored as it's probably not intended as a reference. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default unmapped List[str] A list to store unmapped identifiers. required unintended List[str] A list to store identifiers of unintended references. required Returns: Type Description Callable The actual function accepting a Match object and returning the replacement strings. Source code in mkdocstrings/plugin.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def fix_ref ( self , unmapped : List [ str ], unintended : List [ str ]) -> Callable : \"\"\" Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we append the identifier to the outer `unintended` list to tell the caller that this unresolved reference should be ignored as it's probably not intended as a reference. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: unmapped: A list to store unmapped identifiers. unintended: A list to store identifiers of unintended references. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): groups = match . groupdict () identifier = groups [ \"identifier\" ] title = groups [ \"title\" ] if title and not identifier : identifier , title = title , identifier try : url = self . url_map [ identifier ] except KeyError : if \" \" in identifier or \"/\" in identifier : # invalid identifier, must not be a intended reference unintended . append ( identifier ) else : unmapped . append ( identifier ) if not title : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" # TODO: we could also use a config option to ignore some identifiers # and to map others to URLs, something like: # references: # ignore: # - \"USERNAME:PASSWORD@\" # map: # some-id: https://example.com return f '<a href=\" { url } \"> { title or identifier } </a>' return inner map_urls ( self , base_url , anchor ) \u00a4 Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocstrings/plugin.py 185 186 187 188 189 190 191 192 193 194 195 196 197 def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\" Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . url_map [ anchor . id ] = base_url + anchor . url for child in anchor . children : self . map_urls ( base_url , child ) on_config ( self , config , ** kwargs ) \u00a4 Hook for the on_config event . In this hook, we instantiate our [ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Source code in mkdocstrings/plugin.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def on_config ( self , config : Config , ** kwargs ) -> Config : \"\"\" Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). \"\"\" if not config [ \"site_url\" ]: raise ConfigurationError ( \"mkdocstrings.plugin: configuration item 'site_url' is required for cross-references\" ) log . debug ( \"mkdocstrings.plugin: Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . mkdocstrings_extension = MkdocstringsExtension ( config = extension_config ) config [ \"markdown_extensions\" ] . append ( self . mkdocstrings_extension ) return config on_page_content ( self , html , page , config , files , ** kwargs ) \u00a4 Hook for the on_page_contents event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Source code in mkdocstrings/plugin.py 172 173 174 175 176 177 178 179 180 181 182 183 def on_page_content ( self , html : str , page : Page , config : Config , files : Files , ** kwargs ) -> str : \"\"\" Hook for the [`on_page_contents` event](https://www.mkdocs.org/user-guide/plugins/#on_page_contents). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. \"\"\" log . debug ( f \"mkdocstrings.plugin: Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . canonical_url , item ) return html on_post_build ( self , config , ** kwargs ) \u00a4 Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [ teardown() method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Source code in mkdocstrings/plugin.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def on_post_build ( self , config : Config , ** kwargs ) -> None : \"\"\" Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [`teardown()` method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. \"\"\" log . debug ( \"mkdocstrings.plugin: Tearing handlers down\" ) teardown () on_post_page ( self , output , page , config , ** kwargs ) \u00a4 Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of mkdocstrings to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [ AUTO_REF ][mkdocstrings.plugin.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Source code in mkdocstrings/plugin.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def on_post_page ( self , output : str , page : Page , config : Config , ** kwargs ) -> str : \"\"\" Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `mkdocstrings` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF`][mkdocstrings.plugin.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. \"\"\" log . debug ( f \"mkdocstrings.plugin: Fixing references in page { page . file . src_path } \" ) placeholder = Placeholder () while re . search ( placeholder . seed , output ) or any ( placeholder . seed in url for url in self . url_map . values ()): placeholder . set_seed () unmapped , unintended = [], [] # type: ignore soup = BeautifulSoup ( output , \"html.parser\" ) placeholder . replace_code_tags ( soup ) fixed_soup = AUTO_REF . sub ( self . fix_ref ( unmapped , unintended ), str ( soup )) if unmapped or unintended : # We do nothing with unintended refs if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \"mkdocstrings.plugin: { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" ) return placeholder . restore_code_tags ( fixed_soup ) on_serve ( self , server , config , builder = None , ** kwargs ) \u00a4 Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Source code in mkdocstrings/plugin.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def on_serve ( self , server : Server , config : Config , builder : Callable = None , ** kwargs ) -> Server : \"\"\" Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. \"\"\" if builder is None : # The builder parameter was added in mkdocs v1.1.1. # See issue https://github.com/mkdocs/mkdocs/issues/1952. builder = list ( server . watcher . _tasks . values ())[ 0 ][ \"func\" ] for element in self . config [ \"watch\" ]: log . debug ( f \"mkdocstrings.plugin: Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) return server Placeholder \u00a4 This class is used as a placeholder store. Placeholders are random, unique strings that temporarily replace <code> nodes in an HTML tree. Why do we replace these nodes with such strings? Because we want to fix cross-references that were not resolved during Markdown conversion, and we must never touch to what's inside of a code block. To ease the process, instead of selecting nodes in the HTML tree with complex filters (I tried, believe me), we simply \"hide\" the code nodes, and bulk-replace unresolved cross-references in the whole HTML text at once, with a regular expression substitution. Once it's done, we bulk-replace code nodes back, with a regular expression substitution again. __init__ ( self ) special \u00a4 Initialization method. Source code in mkdocstrings/plugin.py 319 320 321 322 323 def __init__ ( self ) -> None : \"\"\"Initialization method.\"\"\" self . ids : Dict [ str , str ] = {} self . seed = \"\" self . set_seed () get_id ( self ) \u00a4 Return a random, unique string. Source code in mkdocstrings/plugin.py 341 342 343 def get_id ( self ) -> str : \"\"\"Return a random, unique string.\"\"\" return f \" { self . seed }{ random . randint ( 0 , 1000000 ) } \" # noqa: S311 (it's not for security/cryptographic purposes) replace_code_tags ( self , soup ) \u00a4 Recursively replace code nodes with navigable strings whose values are unique IDs. Parameters: Name Type Description Default soup BeautifulSoup The root tag of a BeautifulSoup HTML tree. required Source code in mkdocstrings/plugin.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def replace_code_tags ( self , soup : BeautifulSoup ) -> None : \"\"\" Recursively replace code nodes with navigable strings whose values are unique IDs. Arguments: soup: The root tag of a BeautifulSoup HTML tree. \"\"\" def recursive_replace ( tag ): if hasattr ( tag , \"contents\" ): for i in range ( len ( tag . contents )): child = tag . contents [ i ] if child . name == \"code\" : tag . contents [ i ] = NavigableString ( self . store ( str ( child ))) else : recursive_replace ( child ) recursive_replace ( soup ) restore_code_tags ( self , soup_str ) \u00a4 Restore code nodes previously replaced by unique placeholders. Parameters: Name Type Description Default soup_str str HTML text. required Returns: Type Description str The same HTML text with placeholders replaced by their respective original code nodes. Source code in mkdocstrings/plugin.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def restore_code_tags ( self , soup_str : str ) -> str : \"\"\" Restore code nodes previously replaced by unique placeholders. Args: soup_str: HTML text. Returns: The same HTML text with placeholders replaced by their respective original code nodes. \"\"\" def replace_placeholder ( match ): placeholder = match . groups ()[ 0 ] return self . ids [ placeholder ] return re . sub ( rf \"( { self . seed } \\d+)\" , replace_placeholder , soup_str ) set_seed ( self ) \u00a4 Reset the seed in self.seed with a random string. Source code in mkdocstrings/plugin.py 345 346 347 def set_seed ( self ) -> None : \"\"\"Reset the seed in `self.seed` with a random string.\"\"\" self . seed = \"\" . join ( random . choices ( string . ascii_letters + string . digits , k = 16 )) store ( self , value ) \u00a4 Store a text under a unique ID, return that ID. Parameters: Name Type Description Default value str The text to store. required Returns: Type Description str The ID under which the text is stored. Source code in mkdocstrings/plugin.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def store ( self , value : str ) -> str : \"\"\" Store a text under a unique ID, return that ID. Arguments: value: The text to store. Returns: The ID under which the text is stored. \"\"\" i = self . get_id () while i in self . ids : i = self . get_id () self . ids [ i ] = value return i","title":"plugin.py"},{"location":"reference/plugin/#mkdocstrings.plugin","text":"This module contains the mkdocs plugin. The plugin instantiates a Markdown extension ([ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension]), and adds it to the list of Markdown extensions used by mkdocs during the on_config event hook . After each page is processed by the Markdown converter, this plugin stores absolute URLs of every HTML anchors it finds to later be able to fix unresolved references. It stores them during the on_page_contents event hook . Just before writing the final HTML to the disc, during the on_post_page event hook , this plugin searches for references of the form [identifier][] or [title][identifier] that were not resolved, and fixes them using the previously stored identifier-URL mapping. Once the documentation is built, the on_post_build event hook is triggered and calls the [ handlers.teardown() method][mkdocstrings.handlers.teardown]. This method is used to teardown the [handlers][mkdocstrings.handlers] that were instantiated during documentation buildup. Finally, when serving the documentation, it can add directories to watch during the on_serve event hook .","title":"mkdocstrings.plugin"},{"location":"reference/plugin/#mkdocstrings.plugin.AUTO_REF","text":"A regular expression to match unresolved Markdown references in the [ on_post_page hook][mkdocstrings.plugin.MkdocstringsPlugin.on_post_page].","title":"AUTO_REF"},{"location":"reference/plugin/#mkdocstrings.plugin.RENDERING_OPTS_KEY","text":"The name of the rendering parameter in YAML configuration blocks.","title":"RENDERING_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.SELECTION_OPTS_KEY","text":"The name of the selection parameter in YAML configuration blocks.","title":"SELECTION_OPTS_KEY"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin","text":"An mkdocs plugin. This plugin defines the following event hooks: on_config on_page_contents on_post_page on_post_build on_serve Check the Developing Plugins page of mkdocs for more information about its plugin system..","title":"MkdocstringsPlugin"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.config_scheme","text":"The configuration options of mkdocstrings , written in mkdocs.yml . Available options are: watch : A list of directories to watch. Only used when serving the documentation with mkdocs. Whenever a file changes in one of directories, the whole documentation is built again, and the browser refreshed. default_handler : The default handler to use. The value is the name of the handler module. Default is \"python\". handlers : Global configuration of handlers. You can set global configuration per handler, applied everywhere, but overridable in each \"autodoc\" instruction. Example: plugins : - mkdocstrings : handlers : python : selection : selection_opt : true rendering : rendering_opt : \"value\" setup_commands : - \"import os\" - \"import django\" - \"os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'my_djang_app.settings')\" - \"django.setup()\" rust : selection : selection_opt : 2","title":"config_scheme"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.__init__","text":"Initialization method. Source code in mkdocstrings/plugin.py 115 116 117 118 119 def __init__ ( self ) -> None : \"\"\"Initialization method.\"\"\" super ( MkdocstringsPlugin , self ) . __init__ () self . mkdocstrings_extension : Optional [ MkdocstringsExtension ] = None self . url_map : Dict [ Any , str ] = {}","title":"__init__()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.fix_ref","text":"Return a repl function for re.sub . In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we append the identifier to the outer unintended list to tell the caller that this unresolved reference should be ignored as it's probably not intended as a reference. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer unmapped list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Parameters: Name Type Description Default unmapped List[str] A list to store unmapped identifiers. required unintended List[str] A list to store identifiers of unintended references. required Returns: Type Description Callable The actual function accepting a Match object and returning the replacement strings. Source code in mkdocstrings/plugin.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 def fix_ref ( self , unmapped : List [ str ], unintended : List [ str ]) -> Callable : \"\"\" Return a `repl` function for [`re.sub`](https://docs.python.org/3/library/re.html#re.sub). In our context, we match Markdown references and replace them with HTML links. When the matched reference's identifier contains a space or slash, we append the identifier to the outer `unintended` list to tell the caller that this unresolved reference should be ignored as it's probably not intended as a reference. When the matched reference's identifier was not mapped to an URL, we append the identifier to the outer `unmapped` list. It generally means the user is trying to cross-reference an object that was not collected and rendered, making it impossible to link to it. We catch this exception in the caller to issue a warning. Arguments: unmapped: A list to store unmapped identifiers. unintended: A list to store identifiers of unintended references. Returns: The actual function accepting a [`Match` object](https://docs.python.org/3/library/re.html#match-objects) and returning the replacement strings. \"\"\" def inner ( match : Match ): groups = match . groupdict () identifier = groups [ \"identifier\" ] title = groups [ \"title\" ] if title and not identifier : identifier , title = title , identifier try : url = self . url_map [ identifier ] except KeyError : if \" \" in identifier or \"/\" in identifier : # invalid identifier, must not be a intended reference unintended . append ( identifier ) else : unmapped . append ( identifier ) if not title : return f \"[ { identifier } ][]\" return f \"[ { title } ][ { identifier } ]\" # TODO: we could also use a config option to ignore some identifiers # and to map others to URLs, something like: # references: # ignore: # - \"USERNAME:PASSWORD@\" # map: # some-id: https://example.com return f '<a href=\" { url } \"> { title or identifier } </a>' return inner","title":"fix_ref()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.map_urls","text":"Recurse on every anchor to map its ID to its absolute URL. This method populates self.url_map by side-effect. Parameters: Name Type Description Default base_url str The base URL to use as a prefix for each anchor's relative URL. required anchor AnchorLink The anchor to process and to recurse on. required Source code in mkdocstrings/plugin.py 185 186 187 188 189 190 191 192 193 194 195 196 197 def map_urls ( self , base_url : str , anchor : AnchorLink ) -> None : \"\"\" Recurse on every anchor to map its ID to its absolute URL. This method populates `self.url_map` by side-effect. Arguments: base_url: The base URL to use as a prefix for each anchor's relative URL. anchor: The anchor to process and to recurse on. \"\"\" self . url_map [ anchor . id ] = base_url + anchor . url for child in anchor . children : self . map_urls ( base_url , child )","title":"map_urls()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","text":"Hook for the on_config event . In this hook, we instantiate our [ MkdocstringsExtension ][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by mkdocs . We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). Source code in mkdocstrings/plugin.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def on_config ( self , config : Config , ** kwargs ) -> Config : \"\"\" Hook for the [`on_config` event](https://www.mkdocs.org/user-guide/plugins/#on_config). In this hook, we instantiate our [`MkdocstringsExtension`][mkdocstrings.extension.MkdocstringsExtension] and add it to the list of Markdown extensions used by `mkdocs`. We pass this plugin's configuration dictionary to the extension when instantiating it (it will need it later when processing markdown to get handlers and their global configurations). \"\"\" if not config [ \"site_url\" ]: raise ConfigurationError ( \"mkdocstrings.plugin: configuration item 'site_url' is required for cross-references\" ) log . debug ( \"mkdocstrings.plugin: Adding extension to the list\" ) theme_name = None if config [ \"theme\" ] . name is None : theme_name = os . path . dirname ( config [ \"theme\" ] . dirs [ 0 ]) else : theme_name = config [ \"theme\" ] . name extension_config = { \"theme_name\" : theme_name , \"mdx\" : config [ \"markdown_extensions\" ], \"mdx_configs\" : config [ \"mdx_configs\" ], \"mkdocstrings\" : self . config , } self . mkdocstrings_extension = MkdocstringsExtension ( config = extension_config ) config [ \"markdown_extensions\" ] . append ( self . mkdocstrings_extension ) return config","title":"on_config()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_page_content","text":"Hook for the on_page_contents event . In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form [title][identifier] or [identifier][] . Source code in mkdocstrings/plugin.py 172 173 174 175 176 177 178 179 180 181 182 183 def on_page_content ( self , html : str , page : Page , config : Config , files : Files , ** kwargs ) -> str : \"\"\" Hook for the [`on_page_contents` event](https://www.mkdocs.org/user-guide/plugins/#on_page_contents). In this hook, we map the IDs of every anchor found in the table of contents to the anchors absolute URLs. This mapping will be used later to fix unresolved reference of the form `[title][identifier]` or `[identifier][]`. \"\"\" log . debug ( f \"mkdocstrings.plugin: Mapping identifiers to URLs for page { page . file . src_path } \" ) for item in page . toc . items : self . map_urls ( page . canonical_url , item ) return html","title":"on_page_content()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_build","text":"Hook for the on_post_build event . This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [ teardown() method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. Source code in mkdocstrings/plugin.py 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def on_post_build ( self , config : Config , ** kwargs ) -> None : \"\"\" Hook for the [`on_post_build` event](https://www.mkdocs.org/user-guide/plugins/#on_post_build). This hook is used to teardown all the handlers that were instantiated and cached during documentation buildup. For example, the [Python handler's collector][mkdocstrings.handlers.python.PythonCollector] opens a subprocess in the background and keeps it open to feed it the \"autodoc\" instructions and get back JSON data. Therefore, it must close it at some point, and it does it in its [`teardown()` method][mkdocstrings.handlers.python.PythonCollector.teardown] which is indirectly called by this hook. \"\"\" log . debug ( \"mkdocstrings.plugin: Tearing handlers down\" ) teardown ()","title":"on_post_build()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_post_page","text":"Hook for the on_post_page event . In this hook, we try to fix unresolved references of the form [title][identifier] or [identifier][] . Doing that allows the user of mkdocstrings to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [ AUTO_REF ][mkdocstrings.plugin.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. Source code in mkdocstrings/plugin.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def on_post_page ( self , output : str , page : Page , config : Config , ** kwargs ) -> str : \"\"\" Hook for the [`on_post_page` event](https://www.mkdocs.org/user-guide/plugins/#on_post_page). In this hook, we try to fix unresolved references of the form `[title][identifier]` or `[identifier][]`. Doing that allows the user of `mkdocstrings` to cross-reference objects in their documentation strings. It uses the native Markdown syntax so it's easy to remember and use. We log a warning for each reference that we couldn't map to an URL, but try to be smart and ignore identifiers that do not look legitimate (sometimes documentation can contain strings matching our [`AUTO_REF`][mkdocstrings.plugin.AUTO_REF] regular expression that did not intend to reference anything). We currently ignore references when their identifier contains a space or a slash. \"\"\" log . debug ( f \"mkdocstrings.plugin: Fixing references in page { page . file . src_path } \" ) placeholder = Placeholder () while re . search ( placeholder . seed , output ) or any ( placeholder . seed in url for url in self . url_map . values ()): placeholder . set_seed () unmapped , unintended = [], [] # type: ignore soup = BeautifulSoup ( output , \"html.parser\" ) placeholder . replace_code_tags ( soup ) fixed_soup = AUTO_REF . sub ( self . fix_ref ( unmapped , unintended ), str ( soup )) if unmapped or unintended : # We do nothing with unintended refs if unmapped and log . isEnabledFor ( logging . WARNING ): for ref in unmapped : log . warning ( f \"mkdocstrings.plugin: { page . file . src_path } : Could not find cross-reference target '[ { ref } ]'\" ) return placeholder . restore_code_tags ( fixed_soup )","title":"on_post_page()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_serve","text":"Hook for the on_serve event . In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by mkdocs . Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. Source code in mkdocstrings/plugin.py 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def on_serve ( self , server : Server , config : Config , builder : Callable = None , ** kwargs ) -> Server : \"\"\" Hook for the [`on_serve` event](https://www.mkdocs.org/user-guide/plugins/#on_serve). In this hook, we add the directories specified in the plugin's configuration to the list of directories watched by `mkdocs`. Whenever a change occurs in one of these directories, the documentation is built again and the site reloaded. \"\"\" if builder is None : # The builder parameter was added in mkdocs v1.1.1. # See issue https://github.com/mkdocs/mkdocs/issues/1952. builder = list ( server . watcher . _tasks . values ())[ 0 ][ \"func\" ] for element in self . config [ \"watch\" ]: log . debug ( f \"mkdocstrings.plugin: Adding directory ' { element } ' to watcher\" ) server . watch ( element , builder ) return server","title":"on_serve()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder","text":"This class is used as a placeholder store. Placeholders are random, unique strings that temporarily replace <code> nodes in an HTML tree. Why do we replace these nodes with such strings? Because we want to fix cross-references that were not resolved during Markdown conversion, and we must never touch to what's inside of a code block. To ease the process, instead of selecting nodes in the HTML tree with complex filters (I tried, believe me), we simply \"hide\" the code nodes, and bulk-replace unresolved cross-references in the whole HTML text at once, with a regular expression substitution. Once it's done, we bulk-replace code nodes back, with a regular expression substitution again.","title":"Placeholder"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.__init__","text":"Initialization method. Source code in mkdocstrings/plugin.py 319 320 321 322 323 def __init__ ( self ) -> None : \"\"\"Initialization method.\"\"\" self . ids : Dict [ str , str ] = {} self . seed = \"\" self . set_seed ()","title":"__init__()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.get_id","text":"Return a random, unique string. Source code in mkdocstrings/plugin.py 341 342 343 def get_id ( self ) -> str : \"\"\"Return a random, unique string.\"\"\" return f \" { self . seed }{ random . randint ( 0 , 1000000 ) } \" # noqa: S311 (it's not for security/cryptographic purposes)","title":"get_id()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.replace_code_tags","text":"Recursively replace code nodes with navigable strings whose values are unique IDs. Parameters: Name Type Description Default soup BeautifulSoup The root tag of a BeautifulSoup HTML tree. required Source code in mkdocstrings/plugin.py 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 def replace_code_tags ( self , soup : BeautifulSoup ) -> None : \"\"\" Recursively replace code nodes with navigable strings whose values are unique IDs. Arguments: soup: The root tag of a BeautifulSoup HTML tree. \"\"\" def recursive_replace ( tag ): if hasattr ( tag , \"contents\" ): for i in range ( len ( tag . contents )): child = tag . contents [ i ] if child . name == \"code\" : tag . contents [ i ] = NavigableString ( self . store ( str ( child ))) else : recursive_replace ( child ) recursive_replace ( soup )","title":"replace_code_tags()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.restore_code_tags","text":"Restore code nodes previously replaced by unique placeholders. Parameters: Name Type Description Default soup_str str HTML text. required Returns: Type Description str The same HTML text with placeholders replaced by their respective original code nodes. Source code in mkdocstrings/plugin.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def restore_code_tags ( self , soup_str : str ) -> str : \"\"\" Restore code nodes previously replaced by unique placeholders. Args: soup_str: HTML text. Returns: The same HTML text with placeholders replaced by their respective original code nodes. \"\"\" def replace_placeholder ( match ): placeholder = match . groups ()[ 0 ] return self . ids [ placeholder ] return re . sub ( rf \"( { self . seed } \\d+)\" , replace_placeholder , soup_str )","title":"restore_code_tags()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.set_seed","text":"Reset the seed in self.seed with a random string. Source code in mkdocstrings/plugin.py 345 346 347 def set_seed ( self ) -> None : \"\"\"Reset the seed in `self.seed` with a random string.\"\"\" self . seed = \"\" . join ( random . choices ( string . ascii_letters + string . digits , k = 16 ))","title":"set_seed()"},{"location":"reference/plugin/#mkdocstrings.plugin.Placeholder.store","text":"Store a text under a unique ID, return that ID. Parameters: Name Type Description Default value str The text to store. required Returns: Type Description str The ID under which the text is stored. Source code in mkdocstrings/plugin.py 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def store ( self , value : str ) -> str : \"\"\" Store a text under a unique ID, return that ID. Arguments: value: The text to store. Returns: The ID under which the text is stored. \"\"\" i = self . get_id () while i in self . ids : i = self . get_id () self . ids [ i ] = value return i","title":"store()"},{"location":"reference/handlers/__init__/","text":"\u00a4 Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache. BaseCollector \u00a4 The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method. collect ( self , identifier , config ) \u00a4 Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description Any Anything you want, as long as you can feed it to the renderer's render method. Source code in mkdocstrings/handlers/__init__.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def collect ( self , identifier : str , config : dict ) -> Any : \"\"\" Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Args: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" raise NotImplementedError teardown ( self ) \u00a4 Placeholder to remember this method can be implemented. Source code in mkdocstrings/handlers/__init__.py 187 188 def teardown ( self ) -> None : \"\"\"Placeholder to remember this method can be implemented.\"\"\" BaseHandler \u00a4 The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need. __init__ ( self , collector , renderer ) special \u00a4 Initialization method. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in mkdocstrings/handlers/__init__.py 200 201 202 203 204 205 206 207 208 209 def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\" Initialization method. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer BaseRenderer \u00a4 The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a FALLBACK_THEME class-variable. __init__ ( self , directory , theme , custom_templates = None ) special \u00a4 Initialization method. If the given theme is not supported (it does not exist), it will look for a FALLBACK_THEME attribute in self to use as a fallback theme. Parameters: Name Type Description Default directory str The name of the directory containing the themes for this renderer. required theme str The name of theme to use. required custom_templates Optional[str] Directory containing custom templates. None Source code in mkdocstrings/handlers/__init__.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def __init__ ( self , directory : str , theme : str , custom_templates : Optional [ str ] = None ) -> None : \"\"\" Initialization method. If the given theme is not supported (it does not exist), it will look for a `FALLBACK_THEME` attribute in `self` to use as a fallback theme. Arguments: directory: The name of the directory containing the themes for this renderer. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] if custom_templates is not None : paths . append ( Path ( custom_templates ) / directory / theme ) themes_dir = Path ( __file__ ) . parent . parent / \"templates\" / directory paths . append ( themes_dir / theme ) if self . FALLBACK_THEME != \"\" : paths . append ( themes_dir / self . FALLBACK_THEME ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths )) # type: ignore self . env . filters [ \"highlight\" ] = do_highlight self . env . filters [ \"any\" ] = do_any render ( self , data , config ) \u00a4 Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/__init__.py 127 128 129 130 131 132 133 134 135 136 137 138 def render ( self , data : Any , config : dict ) -> str : \"\"\" Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" raise NotImplementedError update_env ( self , md , config ) \u00a4 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/__init__.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def update_env ( self , md : Markdown , config : dict ) -> None : \"\"\" Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" # Re-instantiate md: see https://github.com/tomchristie/mkautodoc/issues/14 md = Markdown ( extensions = config [ \"mdx\" ], extensions_configs = config [ \"mdx_configs\" ]) def convert_markdown ( text ): return do_mark_safe ( md . convert ( text )) self . env . filters [ \"convert_markdown\" ] = convert_markdown CollectionError \u00a4 An exception raised when some collection of data failed. ThemeNotSupported \u00a4 An exception raised to tell a theme is not supported. do_any ( seq , attribute = None ) \u00a4 The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in mkdocstrings/handlers/__init__.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\" The `any` builtin as a filter for Jinja templates. Args: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( o [ attribute ] for o in seq ) do_highlight ( src , guess_lang = False , language = None , inline = False , dedent = True , line_nums = False , line_start = 1 ) \u00a4 A code-snippet highlighting function for Jinja templates. Parameters: Name Type Description Default src str The code to highlight. required guess_lang bool Whether to guess the language or not. False language str Explicitly tell what language to use for highlighting. None inline bool Whether to do inline highlighting. False dedent bool Whether to dedent the code before highlighting it or not. True line_nums bool Whether to add line numbers in the result. False line_start int The line number to start with. 1 Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in mkdocstrings/handlers/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def do_highlight ( src : str , guess_lang : bool = False , language : str = None , inline : bool = False , dedent : bool = True , line_nums : bool = False , line_start : int = 1 , ) -> str : \"\"\" A code-snippet highlighting function for Jinja templates. Args: src: The code to highlight. guess_lang: Whether to guess the language or not. language: Explicitly tell what language to use for highlighting. inline: Whether to do inline highlighting. dedent: Whether to dedent the code before highlighting it or not. line_nums: Whether to add line numbers in the result. line_start: The line number to start with. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if dedent : src = textwrap . dedent ( src ) highlighter = Highlight ( use_pygments = True , guess_lang = guess_lang , linenums = line_nums ) result = highlighter . highlight ( src = src , language = language , linestart = line_start , inline = inline ) if inline : return do_mark_safe ( result . text ) return do_mark_safe ( result ) get_handler ( name , theme , custom_templates = None , ** config ) \u00a4 Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required theme str The name of the theme to use. required custom_templates Optional[str] Directory containing custom templates. None config Any Configuration passed to the handler. {} Returns: Type Description BaseHandler An instance of a subclass of [ BaseHandler ][mkdocstrings.handlers.BaseHandler], as instantiated by the get_handler method of the handler's module. Source code in mkdocstrings/handlers/__init__.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def get_handler ( name : str , theme : str , custom_templates : Optional [ str ] = None , ** config : Any ,) -> BaseHandler : \"\"\" Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Args: name: The name of the handler. Really, it's the name of the Python module holding it. theme: The name of the theme to use. custom_templates: Directory containing custom templates. config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in HANDLERS_CACHE : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) HANDLERS_CACHE [ name ] = module . get_handler ( theme , custom_templates , ** config ) # type: ignore return HANDLERS_CACHE [ name ] teardown () \u00a4 Teardown all cached handlers and clear the cache. Source code in mkdocstrings/handlers/__init__.py 237 238 239 240 241 242 243 244 def teardown () -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in HANDLERS_CACHE . values (): handler . collector . teardown () del handler . collector del handler . renderer del handler HANDLERS_CACHE . clear ()","title":"__init__.py"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers","text":"Base module for handlers. This module contains the base classes for implementing collectors, renderers, and the combination of the two: handlers. It also provides two methods: get_handler , that will cache handlers into the HANDLERS_CACHE dictionary. teardown , that will teardown all the cached handlers, and then clear the cache.","title":"mkdocstrings.handlers"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector","text":"The base collector class. Inherit from this class to implement a collector. You will have to implement the collect method. You can also implement the teardown method.","title":"BaseCollector"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector.collect","text":"Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Parameters: Name Type Description Default identifier str An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. required config dict Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. required Returns: Type Description Any Anything you want, as long as you can feed it to the renderer's render method. Source code in mkdocstrings/handlers/__init__.py 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 def collect ( self , identifier : str , config : dict ) -> Any : \"\"\" Collect data given an identifier and selection configuration. In the implementation, you typically call a subprocess that returns JSON, and load that JSON again into a Python dictionary for example, though the implementation is completely free. Args: identifier: An identifier for which to collect data. For example, in Python, it would be 'mkdocstrings.handlers' to collect documentation about the handlers module. It can be anything that you can feed to the tool of your choice. config: Configuration options for the tool you use to collect data. Typically called \"selection\" because these options modify how the objects or documentation are \"selected\" in the source code. Returns: Anything you want, as long as you can feed it to the renderer's `render` method. \"\"\" raise NotImplementedError","title":"collect()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseCollector.teardown","text":"Placeholder to remember this method can be implemented. Source code in mkdocstrings/handlers/__init__.py 187 188 def teardown ( self ) -> None : \"\"\"Placeholder to remember this method can be implemented.\"\"\"","title":"teardown()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseHandler","text":"The base handler class. Inherit from this class to implement a handler. It's usually just a combination of a collector and a renderer, but you can make it as complex as you need.","title":"BaseHandler"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseHandler.__init__","text":"Initialization method. Parameters: Name Type Description Default collector BaseCollector A collector instance. required renderer BaseRenderer A renderer instance. required Source code in mkdocstrings/handlers/__init__.py 200 201 202 203 204 205 206 207 208 209 def __init__ ( self , collector : BaseCollector , renderer : BaseRenderer ) -> None : \"\"\" Initialization method. Arguments: collector: A collector instance. renderer: A renderer instance. \"\"\" self . collector = collector self . renderer = renderer","title":"__init__()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer","text":"The base renderer class. Inherit from this class to implement a renderer. You will have to implement the render method. You can also override the update_env method, to add more filters to the Jinja environment, making them available in your Jinja templates. To define a fallback theme, add a FALLBACK_THEME class-variable.","title":"BaseRenderer"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.__init__","text":"Initialization method. If the given theme is not supported (it does not exist), it will look for a FALLBACK_THEME attribute in self to use as a fallback theme. Parameters: Name Type Description Default directory str The name of the directory containing the themes for this renderer. required theme str The name of theme to use. required custom_templates Optional[str] Directory containing custom templates. None Source code in mkdocstrings/handlers/__init__.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def __init__ ( self , directory : str , theme : str , custom_templates : Optional [ str ] = None ) -> None : \"\"\" Initialization method. If the given theme is not supported (it does not exist), it will look for a `FALLBACK_THEME` attribute in `self` to use as a fallback theme. Arguments: directory: The name of the directory containing the themes for this renderer. theme: The name of theme to use. custom_templates: Directory containing custom templates. \"\"\" paths = [] if custom_templates is not None : paths . append ( Path ( custom_templates ) / directory / theme ) themes_dir = Path ( __file__ ) . parent . parent / \"templates\" / directory paths . append ( themes_dir / theme ) if self . FALLBACK_THEME != \"\" : paths . append ( themes_dir / self . FALLBACK_THEME ) self . env = Environment ( autoescape = True , loader = FileSystemLoader ( paths )) # type: ignore self . env . filters [ \"highlight\" ] = do_highlight self . env . filters [ \"any\" ] = do_any","title":"__init__()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/__init__.py 127 128 129 130 131 132 133 134 135 136 137 138 def render ( self , data : Any , config : dict ) -> str : \"\"\" Render a template using provided data and configuration options. Arguments: data: The collected data to render. config: The rendering options. Returns: The rendered template as HTML. \"\"\" raise NotImplementedError","title":"render()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.BaseRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/__init__.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def update_env ( self , md : Markdown , config : dict ) -> None : \"\"\" Update the Jinja environment. Arguments: md: The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. config: Configuration options for `mkdocs` and `mkdocstrings`, read from `mkdocs.yml`. See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. \"\"\" # Re-instantiate md: see https://github.com/tomchristie/mkautodoc/issues/14 md = Markdown ( extensions = config [ \"mdx\" ], extensions_configs = config [ \"mdx_configs\" ]) def convert_markdown ( text ): return do_mark_safe ( md . convert ( text )) self . env . filters [ \"convert_markdown\" ] = convert_markdown","title":"update_env()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.CollectionError","text":"An exception raised when some collection of data failed.","title":"CollectionError"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.ThemeNotSupported","text":"An exception raised to tell a theme is not supported.","title":"ThemeNotSupported"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.do_any","text":"The any builtin as a filter for Jinja templates. Parameters: Name Type Description Default seq Sequence An iterable object. required attribute str The attribute name to use on each object of the iterable. None Returns: Type Description bool A boolean telling if any object of the iterable evaluated to True. Source code in mkdocstrings/handlers/__init__.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def do_any ( seq : Sequence , attribute : str = None ) -> bool : \"\"\" The `any` builtin as a filter for Jinja templates. Args: seq: An iterable object. attribute: The attribute name to use on each object of the iterable. Returns: A boolean telling if any object of the iterable evaluated to True. \"\"\" if attribute is None : return any ( seq ) return any ( o [ attribute ] for o in seq )","title":"do_any()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.do_highlight","text":"A code-snippet highlighting function for Jinja templates. Parameters: Name Type Description Default src str The code to highlight. required guess_lang bool Whether to guess the language or not. False language str Explicitly tell what language to use for highlighting. None inline bool Whether to do inline highlighting. False dedent bool Whether to dedent the code before highlighting it or not. True line_nums bool Whether to add line numbers in the result. False line_start int The line number to start with. 1 Returns: Type Description str The highlighted code as HTML text, marked safe (not escaped for HTML). Source code in mkdocstrings/handlers/__init__.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 def do_highlight ( src : str , guess_lang : bool = False , language : str = None , inline : bool = False , dedent : bool = True , line_nums : bool = False , line_start : int = 1 , ) -> str : \"\"\" A code-snippet highlighting function for Jinja templates. Args: src: The code to highlight. guess_lang: Whether to guess the language or not. language: Explicitly tell what language to use for highlighting. inline: Whether to do inline highlighting. dedent: Whether to dedent the code before highlighting it or not. line_nums: Whether to add line numbers in the result. line_start: The line number to start with. Returns: The highlighted code as HTML text, marked safe (not escaped for HTML). \"\"\" if dedent : src = textwrap . dedent ( src ) highlighter = Highlight ( use_pygments = True , guess_lang = guess_lang , linenums = line_nums ) result = highlighter . highlight ( src = src , language = language , linestart = line_start , inline = inline ) if inline : return do_mark_safe ( result . text ) return do_mark_safe ( result )","title":"do_highlight()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.get_handler","text":"Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its get_handler method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Parameters: Name Type Description Default name str The name of the handler. Really, it's the name of the Python module holding it. required theme str The name of the theme to use. required custom_templates Optional[str] Directory containing custom templates. None config Any Configuration passed to the handler. {} Returns: Type Description BaseHandler An instance of a subclass of [ BaseHandler ][mkdocstrings.handlers.BaseHandler], as instantiated by the get_handler method of the handler's module. Source code in mkdocstrings/handlers/__init__.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def get_handler ( name : str , theme : str , custom_templates : Optional [ str ] = None , ** config : Any ,) -> BaseHandler : \"\"\" Get a handler thanks to its name. This function dynamically imports a module named \"mkdocstrings.handlers.NAME\", calls its `get_handler` method to get an instance of a handler, and caches it in dictionary. It means that during one run (for each reload when serving, or once when building), a handler is instantiated only once, and reused for each \"autodoc\" instruction asking for it. Args: name: The name of the handler. Really, it's the name of the Python module holding it. theme: The name of the theme to use. custom_templates: Directory containing custom templates. config: Configuration passed to the handler. Returns: An instance of a subclass of [`BaseHandler`][mkdocstrings.handlers.BaseHandler], as instantiated by the `get_handler` method of the handler's module. \"\"\" if name not in HANDLERS_CACHE : module = importlib . import_module ( f \"mkdocstrings.handlers. { name } \" ) HANDLERS_CACHE [ name ] = module . get_handler ( theme , custom_templates , ** config ) # type: ignore return HANDLERS_CACHE [ name ]","title":"get_handler()"},{"location":"reference/handlers/__init__/#mkdocstrings.handlers.teardown","text":"Teardown all cached handlers and clear the cache. Source code in mkdocstrings/handlers/__init__.py 237 238 239 240 241 242 243 244 def teardown () -> None : \"\"\"Teardown all cached handlers and clear the cache.\"\"\" for handler in HANDLERS_CACHE . values (): handler . collector . teardown () del handler . collector del handler . renderer del handler HANDLERS_CACHE . clear ()","title":"teardown()"},{"location":"reference/handlers/python/","text":"\u00a4 This module implements a handler for the Python language. The handler collects data with pytkdocs . PythonCollector \u00a4 The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer]. DEFAULT_CONFIG: dict class-attribute \u00a4 The default selection options. Option Type Description Default filters List[str] Filter members with regular expressions. [ \"!^_[^_]\" ] members Union[bool, List[str]] Explicitly select the object members. pytkdocs default: True If members is a list of names, filters are applied only on the members children (not the members themselves). If members is False , none are selected. If members is True or an empty list, filters are applied on all members and their children. Members affect only the first layer of objects, while filters affect the whole object-tree recursively. Every filters is run against every object name. An object can be un-selected by a filter and re-selected by the next one: \"!^_\" : exclude all objects starting with an underscore \"^__\" : but select all objects starting with two underscores Obviously one could use a single filter instead: \"!^_[^_]\" , which is the default. __init__ ( self , setup_commands = None ) special \u00a4 Initialization method. When instantiating a Python collector, we open a subprocess in the background with subprocess.Popen . It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down mkdocstrings a lot. Parameters: Name Type Description Default setup_commands Optional[List[str]] A list of python commands as strings to be executed in the subprocess before pytkdocs . None Source code in mkdocstrings/handlers/python.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , setup_commands : Optional [ List [ str ]] = None ) -> None : \"\"\" Initialization method. When instantiating a Python collector, we open a subprocess in the background with `subprocess.Popen`. It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down `mkdocstrings` a lot. Arguments: setup_commands: A list of python commands as strings to be executed in the subprocess before `pytkdocs`. \"\"\" log . debug ( \"mkdocstrings.handlers.python: Opening 'pytkdocs' subprocess\" ) env = os . environ . copy () env [ \"PYTHONUNBUFFERED\" ] = \"1\" if setup_commands : # prevent the Python interpreter or the setup commands # from writing to stdout as it would break pytkdocs output commands = [ \"import sys\" , \"from io import StringIO\" , \"from pytkdocs.cli import main as pytkdocs\" , \"sys.stdout = StringIO()\" , # redirect stdout to memory buffer * setup_commands , \"sys.stdout.flush()\" , \"sys.stdout = sys.__stdout__\" , # restore stdout \"pytkdocs(['--line-by-line'])\" , ] cmd = [ sys . executable , \"-c\" , \"; \" . join ( commands )] else : cmd = [ \"pytkdocs\" , \"--line-by-line\" ] self . process = Popen ( # noqa: S603,S607 (we trust the input, and we don't want to use the absolute path) cmd , universal_newlines = True , stderr = PIPE , stdout = PIPE , stdin = PIPE , bufsize =- 1 , env = env , ) collect ( self , identifier , config ) \u00a4 Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an error key, we log it as error (with the optional traceback value), and raise a CollectionError. If the dictionary values for keys loading_errors and parsing_errors are not empty, we log them as warnings. Then we pick up the only object within the objects list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [ rebuild_category_lists() ][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Parameters: Name Type Description Default identifier str The dotted-path of a Python object available in the Python path. required config dict Selection options, used to alter the data collection done by pytkdocs . required Returns: Type Description Any The collected object-tree. Source code in mkdocstrings/handlers/python.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def collect ( self , identifier : str , config : dict ) -> Any : \"\"\" Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an `error` key, we log it as error (with the optional `traceback` value), and raise a CollectionError. If the dictionary values for keys `loading_errors` and `parsing_errors` are not empty, we log them as warnings. Then we pick up the only object within the `objects` list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [`rebuild_category_lists()`][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Arguments: identifier: The dotted-path of a Python object available in the Python path. config: Selection options, used to alter the data collection done by `pytkdocs`. Returns: The collected object-tree. \"\"\" final_config = dict ( self . DEFAULT_CONFIG ) final_config . update ( config ) log . debug ( \"mkdocstrings.handlers.python: Preparing input\" ) json_input = json . dumps ({ \"objects\" : [{ \"path\" : identifier , ** final_config }]}) log . debug ( \"mkdocstrings.handlers.python: Writing to process' stdin\" ) print ( json_input , file = self . process . stdin , flush = True ) log . debug ( \"mkdocstrings.handlers.python: Reading process' stdout\" ) stdout = self . process . stdout . readline () # type: ignore log . debug ( \"mkdocstrings.handlers.python: Loading JSON output as Python object\" ) try : result = json . loads ( stdout ) except json . decoder . JSONDecodeError as exception : log . error ( f \"mkdocstrings.handlers.python: Error while loading JSON: { stdout } \" ) raise CollectionError ( str ( exception )) if \"error\" in result : message = f \"mkdocstrings.handlers.python: Collection failed: { result [ 'error' ] } \" if \"traceback\" in result : message += f \" \\n { result [ 'traceback' ] } \" log . error ( message ) raise CollectionError ( result [ \"error\" ]) if result [ \"loading_errors\" ]: for error in result [ \"loading_errors\" ]: log . warning ( f \"mkdocstrings.handlers.python: { error } \" ) if result [ \"parsing_errors\" ]: for path , errors in result [ \"parsing_errors\" ] . items (): # type: ignore for error in errors : log . warning ( f \"mkdocstrings.handlers.python: { error } \" ) # We always collect only one object at a time result = result [ \"objects\" ][ 0 ] log . debug ( \"mkdocstrings.handlers.python: Rebuilding categories and children lists\" ) rebuild_category_lists ( result ) return result teardown ( self ) \u00a4 Terminate the opened subprocess, set it to None . Source code in mkdocstrings/handlers/python.py 223 224 225 226 def teardown ( self ) -> None : \"\"\"Terminate the opened subprocess, set it to `None`.\"\"\" log . debug ( \"mkdocstrings.handlers.python: Tearing process down\" ) self . process . terminate () PythonHandler \u00a4 The Python handler class, nothing specific here. PythonRenderer \u00a4 The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer]. DEFAULT_CONFIG: dict class-attribute \u00a4 The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2 render ( self , data , config ) \u00a4 Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/python.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def render ( self , data : Any , config : dict ) -> str : # noqa: D102 (ignore missing docstring) final_config = dict ( self . DEFAULT_CONFIG ) final_config . update ( config ) template = self . env . get_template ( f \" { data [ 'category' ] } .html\" ) # Heading level is a \"state\" variable, that will change at each step # of the rendering recursion. Therefore, it's easier to use it as a plain value # than as an item in a dictionary. heading_level = final_config . pop ( \"heading_level\" ) return template . render ( ** { \"config\" : final_config , data [ \"category\" ]: data , \"heading_level\" : heading_level , \"root\" : True } ) update_env ( self , md , config ) \u00a4 Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/python.py 75 76 77 78 79 def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: D102 (ignore missing docstring) super ( PythonRenderer , self ) . update_env ( md , config ) self . env . trim_blocks = True self . env . lstrip_blocks = True self . env . keep_trailing_newline = False get_handler ( theme , custom_templates = None , setup_commands = None , ** kwargs ) \u00a4 Simply return an instance of PythonHandler . Parameters: Name Type Description Default theme str The theme to use when rendering contents. required custom_templates Optional[str] Directory containing custom templates. None setup_commands Optional[List[str]] A list of commands as strings to be executed in the subprocess before pytkdocs . None Returns: Type Description PythonHandler An instance of PythonHandler . Source code in mkdocstrings/handlers/python.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def get_handler ( theme : str , custom_templates : Optional [ str ] = None , setup_commands : Optional [ List [ str ]] = None , ** kwargs : Any ) -> PythonHandler : \"\"\" Simply return an instance of `PythonHandler`. Arguments: theme: The theme to use when rendering contents. custom_templates: Directory containing custom templates. setup_commands: A list of commands as strings to be executed in the subprocess before `pytkdocs`. Returns: An instance of `PythonHandler`. \"\"\" return PythonHandler ( collector = PythonCollector ( setup_commands = setup_commands ), renderer = PythonRenderer ( \"python\" , theme , custom_templates ), ) rebuild_category_lists ( obj ) \u00a4 Recursively rebuild the category lists of a collected object. Since pytkdocs dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a children list, containing all children, and another list for each category of children: attributes , classes , functions , methods and modules . It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the children list using their path. For each object, we recurse on every one of its children. Parameters: Name Type Description Default obj dict The collected object, loaded back from JSON into a Python dictionary. required Source code in mkdocstrings/handlers/python.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def rebuild_category_lists ( obj : dict ) -> None : \"\"\" Recursively rebuild the category lists of a collected object. Since `pytkdocs` dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a `children` list, containing all children, and another list for each category of children: `attributes`, `classes`, `functions`, `methods` and `modules`. It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the `children` list using their path. For each object, we recurse on every one of its children. Args: obj: The collected object, loaded back from JSON into a Python dictionary. \"\"\" obj [ \"attributes\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"attributes\" ]] obj [ \"classes\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"classes\" ]] obj [ \"functions\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"functions\" ]] obj [ \"methods\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"methods\" ]] obj [ \"modules\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"modules\" ]] obj [ \"children\" ] = [ v for k , v in obj [ \"children\" ] . items ()] for child in obj [ \"children\" ]: rebuild_category_lists ( child )","title":"python.py"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python","text":"This module implements a handler for the Python language. The handler collects data with pytkdocs .","title":"mkdocstrings.handlers.python"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector","text":"The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer].","title":"PythonCollector"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.DEFAULT_CONFIG","text":"The default selection options. Option Type Description Default filters List[str] Filter members with regular expressions. [ \"!^_[^_]\" ] members Union[bool, List[str]] Explicitly select the object members. pytkdocs default: True If members is a list of names, filters are applied only on the members children (not the members themselves). If members is False , none are selected. If members is True or an empty list, filters are applied on all members and their children. Members affect only the first layer of objects, while filters affect the whole object-tree recursively. Every filters is run against every object name. An object can be un-selected by a filter and re-selected by the next one: \"!^_\" : exclude all objects starting with an underscore \"^__\" : but select all objects starting with two underscores Obviously one could use a single filter instead: \"!^_[^_]\" , which is the default.","title":"DEFAULT_CONFIG"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.__init__","text":"Initialization method. When instantiating a Python collector, we open a subprocess in the background with subprocess.Popen . It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down mkdocstrings a lot. Parameters: Name Type Description Default setup_commands Optional[List[str]] A list of python commands as strings to be executed in the subprocess before pytkdocs . None Source code in mkdocstrings/handlers/python.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def __init__ ( self , setup_commands : Optional [ List [ str ]] = None ) -> None : \"\"\" Initialization method. When instantiating a Python collector, we open a subprocess in the background with `subprocess.Popen`. It will allow us to feed input to and read output from this subprocess, keeping it alive during the whole documentation generation. Spawning a new Python subprocess for each \"autodoc\" instruction would be too resource intensive, and would slow down `mkdocstrings` a lot. Arguments: setup_commands: A list of python commands as strings to be executed in the subprocess before `pytkdocs`. \"\"\" log . debug ( \"mkdocstrings.handlers.python: Opening 'pytkdocs' subprocess\" ) env = os . environ . copy () env [ \"PYTHONUNBUFFERED\" ] = \"1\" if setup_commands : # prevent the Python interpreter or the setup commands # from writing to stdout as it would break pytkdocs output commands = [ \"import sys\" , \"from io import StringIO\" , \"from pytkdocs.cli import main as pytkdocs\" , \"sys.stdout = StringIO()\" , # redirect stdout to memory buffer * setup_commands , \"sys.stdout.flush()\" , \"sys.stdout = sys.__stdout__\" , # restore stdout \"pytkdocs(['--line-by-line'])\" , ] cmd = [ sys . executable , \"-c\" , \"; \" . join ( commands )] else : cmd = [ \"pytkdocs\" , \"--line-by-line\" ] self . process = Popen ( # noqa: S603,S607 (we trust the input, and we don't want to use the absolute path) cmd , universal_newlines = True , stderr = PIPE , stdout = PIPE , stdin = PIPE , bufsize =- 1 , env = env , )","title":"__init__()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.collect","text":"Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an error key, we log it as error (with the optional traceback value), and raise a CollectionError. If the dictionary values for keys loading_errors and parsing_errors are not empty, we log them as warnings. Then we pick up the only object within the objects list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [ rebuild_category_lists() ][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Parameters: Name Type Description Default identifier str The dotted-path of a Python object available in the Python path. required config dict Selection options, used to alter the data collection done by pytkdocs . required Returns: Type Description Any The collected object-tree. Source code in mkdocstrings/handlers/python.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def collect ( self , identifier : str , config : dict ) -> Any : \"\"\" Collect the documentation tree given an identifier and selection options. In this method, we feed one line of JSON to the standard input of the subprocess that was opened during instantiation of the collector. Then we read one line of JSON on its standard output. We load back the JSON text into a Python dictionary. If there is a decoding error, we log it as error and raise a CollectionError. If the dictionary contains an `error` key, we log it as error (with the optional `traceback` value), and raise a CollectionError. If the dictionary values for keys `loading_errors` and `parsing_errors` are not empty, we log them as warnings. Then we pick up the only object within the `objects` list (there's always only one, because we collect them one by one), rebuild it's categories lists (see [`rebuild_category_lists()`][mkdocstrings.handlers.python.rebuild_category_lists]), and return it. Arguments: identifier: The dotted-path of a Python object available in the Python path. config: Selection options, used to alter the data collection done by `pytkdocs`. Returns: The collected object-tree. \"\"\" final_config = dict ( self . DEFAULT_CONFIG ) final_config . update ( config ) log . debug ( \"mkdocstrings.handlers.python: Preparing input\" ) json_input = json . dumps ({ \"objects\" : [{ \"path\" : identifier , ** final_config }]}) log . debug ( \"mkdocstrings.handlers.python: Writing to process' stdin\" ) print ( json_input , file = self . process . stdin , flush = True ) log . debug ( \"mkdocstrings.handlers.python: Reading process' stdout\" ) stdout = self . process . stdout . readline () # type: ignore log . debug ( \"mkdocstrings.handlers.python: Loading JSON output as Python object\" ) try : result = json . loads ( stdout ) except json . decoder . JSONDecodeError as exception : log . error ( f \"mkdocstrings.handlers.python: Error while loading JSON: { stdout } \" ) raise CollectionError ( str ( exception )) if \"error\" in result : message = f \"mkdocstrings.handlers.python: Collection failed: { result [ 'error' ] } \" if \"traceback\" in result : message += f \" \\n { result [ 'traceback' ] } \" log . error ( message ) raise CollectionError ( result [ \"error\" ]) if result [ \"loading_errors\" ]: for error in result [ \"loading_errors\" ]: log . warning ( f \"mkdocstrings.handlers.python: { error } \" ) if result [ \"parsing_errors\" ]: for path , errors in result [ \"parsing_errors\" ] . items (): # type: ignore for error in errors : log . warning ( f \"mkdocstrings.handlers.python: { error } \" ) # We always collect only one object at a time result = result [ \"objects\" ][ 0 ] log . debug ( \"mkdocstrings.handlers.python: Rebuilding categories and children lists\" ) rebuild_category_lists ( result ) return result","title":"collect()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonCollector.teardown","text":"Terminate the opened subprocess, set it to None . Source code in mkdocstrings/handlers/python.py 223 224 225 226 def teardown ( self ) -> None : \"\"\"Terminate the opened subprocess, set it to `None`.\"\"\" log . debug ( \"mkdocstrings.handlers.python: Tearing process down\" ) self . process . terminate ()","title":"teardown()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonHandler","text":"The Python handler class, nothing specific here.","title":"PythonHandler"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer","text":"The class responsible for loading Jinja templates and rendering them. It defines some configuration options, implements the render method, and overrides the update_env method of the [ BaseRenderer class][mkdocstrings.handlers.BaseRenderer].","title":"PythonRenderer"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.DEFAULT_CONFIG","text":"The default rendering options. Option Type Description Default show_root_heading bool Show the heading of the object at the root of the documentation tree. False show_root_toc_entry bool If the root heading is not shown, at least add a ToC entry for it. True show_root_full_path bool Show the full Python path for the root object heading. True show_object_full_path bool Show the full Python path of every object. False show_category_heading bool When grouped by categories, show a heading for each category. False show_if_no_docstring bool Show the object heading even if it has no docstring or children with docstrings. False show_source bool Show the source code of this object. True group_by_category bool Group the object's children by categories: attributes, classes, functions, methods, and modules. True heading_level int The initial heading level to use. 2","title":"DEFAULT_CONFIG"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.render","text":"Render a template using provided data and configuration options. Parameters: Name Type Description Default data Any The collected data to render. required config dict The rendering options. required Returns: Type Description str The rendered template as HTML. Source code in mkdocstrings/handlers/python.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def render ( self , data : Any , config : dict ) -> str : # noqa: D102 (ignore missing docstring) final_config = dict ( self . DEFAULT_CONFIG ) final_config . update ( config ) template = self . env . get_template ( f \" { data [ 'category' ] } .html\" ) # Heading level is a \"state\" variable, that will change at each step # of the rendering recursion. Therefore, it's easier to use it as a plain value # than as an item in a dictionary. heading_level = final_config . pop ( \"heading_level\" ) return template . render ( ** { \"config\" : final_config , data [ \"category\" ]: data , \"heading_level\" : heading_level , \"root\" : True } )","title":"render()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.PythonRenderer.update_env","text":"Update the Jinja environment. Parameters: Name Type Description Default md Markdown The Markdown instance. Useful to add functions able to convert Markdown into the environment filters. required config dict Configuration options for mkdocs and mkdocstrings , read from mkdocs.yml . See the source code of [mkdocstrings.plugin.MkdocstringsPlugin.on_config][] to see what's in this dictionary. required Source code in mkdocstrings/handlers/python.py 75 76 77 78 79 def update_env ( self , md : Markdown , config : dict ) -> None : # noqa: D102 (ignore missing docstring) super ( PythonRenderer , self ) . update_env ( md , config ) self . env . trim_blocks = True self . env . lstrip_blocks = True self . env . keep_trailing_newline = False","title":"update_env()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.get_handler","text":"Simply return an instance of PythonHandler . Parameters: Name Type Description Default theme str The theme to use when rendering contents. required custom_templates Optional[str] Directory containing custom templates. None setup_commands Optional[List[str]] A list of commands as strings to be executed in the subprocess before pytkdocs . None Returns: Type Description PythonHandler An instance of PythonHandler . Source code in mkdocstrings/handlers/python.py 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def get_handler ( theme : str , custom_templates : Optional [ str ] = None , setup_commands : Optional [ List [ str ]] = None , ** kwargs : Any ) -> PythonHandler : \"\"\" Simply return an instance of `PythonHandler`. Arguments: theme: The theme to use when rendering contents. custom_templates: Directory containing custom templates. setup_commands: A list of commands as strings to be executed in the subprocess before `pytkdocs`. Returns: An instance of `PythonHandler`. \"\"\" return PythonHandler ( collector = PythonCollector ( setup_commands = setup_commands ), renderer = PythonRenderer ( \"python\" , theme , custom_templates ), )","title":"get_handler()"},{"location":"reference/handlers/python/#mkdocstrings.handlers.python.rebuild_category_lists","text":"Recursively rebuild the category lists of a collected object. Since pytkdocs dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a children list, containing all children, and another list for each category of children: attributes , classes , functions , methods and modules . It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the children list using their path. For each object, we recurse on every one of its children. Parameters: Name Type Description Default obj dict The collected object, loaded back from JSON into a Python dictionary. required Source code in mkdocstrings/handlers/python.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def rebuild_category_lists ( obj : dict ) -> None : \"\"\" Recursively rebuild the category lists of a collected object. Since `pytkdocs` dumps JSON on standard output, it must serialize the object-tree and flatten it to reduce data duplication and avoid cycle-references. Indeed, each node of the object-tree has a `children` list, containing all children, and another list for each category of children: `attributes`, `classes`, `functions`, `methods` and `modules`. It replaces the values in category lists with only the paths of the objects. Here, we reconstruct these category lists by picking objects in the `children` list using their path. For each object, we recurse on every one of its children. Args: obj: The collected object, loaded back from JSON into a Python dictionary. \"\"\" obj [ \"attributes\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"attributes\" ]] obj [ \"classes\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"classes\" ]] obj [ \"functions\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"functions\" ]] obj [ \"methods\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"methods\" ]] obj [ \"modules\" ] = [ obj [ \"children\" ][ path ] for path in obj [ \"modules\" ]] obj [ \"children\" ] = [ v for k , v in obj [ \"children\" ] . items ()] for child in obj [ \"children\" ]: rebuild_category_lists ( child )","title":"rebuild_category_lists()"}]}