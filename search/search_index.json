{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"mkdocstrings \u00b6 Automatic documentation from docstrings, for mkdocs. This plugin is still in alpha status. Here is how it looks with the mkdocs-material theme for now: Requirements \u00b6 mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8 Installation \u00b6 With pip : python3.6 -m pip install mkdocstrings With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 mkdocstrings Usage \u00b6 # mkdocs.yml # designed to work best with material theme theme : name : \"material\" # these extensions are required for best results markdown_extensions : - admonition - codehilite - attr_list - pymdownx.details - pymdownx.superfences - pymdownx.inlinehilite - toc : permalink : true plugins : - search - mkdocstrings # Reference ::: my_library . my_module . my_class You can reference objects from other modules in your docstrings: def some_function (): \"\"\" This is my function. It references [another function][package.submodule.function]. It also references another object directly: [package.submodule.SuperClass][]. \"\"\" pass Add some style: div . autodoc { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); }","title":"Overview"},{"location":"#mkdocstrings","text":"Automatic documentation from docstrings, for mkdocs. This plugin is still in alpha status. Here is how it looks with the mkdocs-material theme for now:","title":"mkdocstrings"},{"location":"#requirements","text":"mkdocstrings requires Python 3.6 or above. To install Python 3.6, I recommend using pyenv . # install pyenv git clone https://github.com/pyenv/pyenv ~/.pyenv # setup pyenv (you should also put these three lines in .bashrc or similar) export PATH = \" ${ HOME } /.pyenv/bin: ${ PATH } \" export PYENV_ROOT = \" ${ HOME } /.pyenv\" eval \" $( pyenv init - ) \" # install Python 3.6 pyenv install 3 .6.8 # make it available globally pyenv global system 3 .6.8","title":"Requirements"},{"location":"#installation","text":"With pip : python3.6 -m pip install mkdocstrings With pipx : python3.6 -m pip install --user pipx pipx install --python python3.6 mkdocstrings","title":"Installation"},{"location":"#usage","text":"# mkdocs.yml # designed to work best with material theme theme : name : \"material\" # these extensions are required for best results markdown_extensions : - admonition - codehilite - attr_list - pymdownx.details - pymdownx.superfences - pymdownx.inlinehilite - toc : permalink : true plugins : - search - mkdocstrings # Reference ::: my_library . my_module . my_class You can reference objects from other modules in your docstrings: def some_function (): \"\"\" This is my function. It references [another function][package.submodule.function]. It also references another object directly: [package.submodule.SuperClass][]. \"\"\" pass Add some style: div . autodoc { padding-left : 25 px ; border-left : 4 px solid rgba ( 230 , 230 , 230 ); }","title":"Usage"},{"location":"changelog/","text":"Changelog \u00b6 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00b6 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. For bug reports, feature requests, and feedback, simply create a new issue . Try to be as descriptive as possible. Bug fixes, new features and documentation \u00b6 This project is developed using poetry . Follow the recommended installation method: curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Then follow these instructions: Fork the repository on gitlab.com ; Clone it on your machine; Go into the directory, and run poetry install to setup the development environment; Create a new branch with git checkout -b bug-fix-or-feature-name ; Code! Write tests. Run them all. The commands to run the tests are: poetry run pytest # to run all tests sequentially poetry run pytest -v # to print one test per line poetry run pytest -n 4 # to run tests in parallel (4 workers) poetry run pytest tests/test_api.py # to run tests in a specific file pytest provides the -k option to select tests based on their names: poetry run pytest -k \"api and remove\" poetry run pytest -k \"utils or stats\" See the documentation for the -k option for more examples. A Makefile is available for convenience: make test . 1. When the tests pass, commit (make sure to have atomic commits and contextual commit messages! Check out this awesome blog post by Chris Beams for more information. ) 1. Push; 1. ...and finally, create a new pull/merge request ! Make sure to follow the guidelines.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. For bug reports, feature requests, and feedback, simply create a new issue . Try to be as descriptive as possible.","title":"Contributing"},{"location":"contributing/#bug-fixes-new-features-and-documentation","text":"This project is developed using poetry . Follow the recommended installation method: curl -sSL https://raw.githubusercontent.com/sdispater/poetry/master/get-poetry.py | python Then follow these instructions: Fork the repository on gitlab.com ; Clone it on your machine; Go into the directory, and run poetry install to setup the development environment; Create a new branch with git checkout -b bug-fix-or-feature-name ; Code! Write tests. Run them all. The commands to run the tests are: poetry run pytest # to run all tests sequentially poetry run pytest -v # to print one test per line poetry run pytest -n 4 # to run tests in parallel (4 workers) poetry run pytest tests/test_api.py # to run tests in a specific file pytest provides the -k option to select tests based on their names: poetry run pytest -k \"api and remove\" poetry run pytest -k \"utils or stats\" See the documentation for the -k option for more examples. A Makefile is available for convenience: make test . 1. When the tests pass, commit (make sure to have atomic commits and contextual commit messages! Check out this awesome blog post by Chris Beams for more information. ) 1. Push; 1. ...and finally, create a new pull/merge request ! Make sure to follow the guidelines.","title":"Bug fixes, new features and documentation"},{"location":"credits/","text":"Credits \u00b6 These projects were used to build mkdocstrings . Thank you! python \" src=\"https://www.vectorlogo.zone/logos/python/python-ar21.svg\" /> | poetry | cookie-poetry Direct dependencies \u00b6 bandit | black | coverage | flake8 | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | pylint | pytest | pytest-cov | pytest-sugar | pytest-xdist | recommonmark | safety | Sphinx | sphinx-rtd-theme | toml Indirect dependencies \u00b6 alabaster | apipkg | appdirs | appnope | astroid | atomicwrites | attrs | Babel | backcall | certifi | chardet | Click | colorama | commonmark \" src=\"https://www.vectorlogo.zone/logos/commonmark/commonmark-ar21.svg\" /> | decorator | docutils | dparse | entrypoints | execnet | gitdb2 | GitPython | htmlmin | idna | imagesize | importlib-metadata | ipython-genutils | jedi | Jinja2 \" src=\"https://www.vectorlogo.zone/logos/pocoo_jinja/pocoo_jinja-ar21.svg\" /> | jsmin | lazy-object-proxy | livereload | Markdown | MarkupSafe | mccabe | mkdocs-minify-plugin | more-itertools | packaging | parso | pathspec | pbr | pep562 | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | pytz | PyYAML | regex | requests | six | smmap2 | snowballstemmer | sphinxcontrib-websupport | stevedore | termcolor | tornado | traitlets | typed-ast | urllib3 | wcwidth | wrapt | zipp More credits from the author See one of your project without the logo? Make sure it's available on VectorLogoZone ( GitHub repo ) and open an issue or send a pull/merge request!","title":"Credits"},{"location":"credits/#credits","text":"These projects were used to build mkdocstrings . Thank you! python \" src=\"https://www.vectorlogo.zone/logos/python/python-ar21.svg\" /> | poetry | cookie-poetry","title":"Credits"},{"location":"credits/#direct-dependencies","text":"bandit | black | coverage | flake8 | ipython | isort | jinja2-cli | mkdocs | mkdocs-material | pylint | pytest | pytest-cov | pytest-sugar | pytest-xdist | recommonmark | safety | Sphinx | sphinx-rtd-theme | toml","title":"Direct dependencies"},{"location":"credits/#indirect-dependencies","text":"alabaster | apipkg | appdirs | appnope | astroid | atomicwrites | attrs | Babel | backcall | certifi | chardet | Click | colorama | commonmark \" src=\"https://www.vectorlogo.zone/logos/commonmark/commonmark-ar21.svg\" /> | decorator | docutils | dparse | entrypoints | execnet | gitdb2 | GitPython | htmlmin | idna | imagesize | importlib-metadata | ipython-genutils | jedi | Jinja2 \" src=\"https://www.vectorlogo.zone/logos/pocoo_jinja/pocoo_jinja-ar21.svg\" /> | jsmin | lazy-object-proxy | livereload | Markdown | MarkupSafe | mccabe | mkdocs-minify-plugin | more-itertools | packaging | parso | pathspec | pbr | pep562 | pexpect | pickleshare | pluggy | prompt-toolkit | ptyprocess | py | pycodestyle | pyflakes | Pygments | pymdown-extensions | pyparsing | pytest-forked | pytz | PyYAML | regex | requests | six | smmap2 | snowballstemmer | sphinxcontrib-websupport | stevedore | termcolor | tornado | traitlets | typed-ast | urllib3 | wcwidth | wrapt | zipp More credits from the author See one of your project without the logo? Make sure it's available on VectorLogoZone ( GitHub repo ) and open an issue or send a pull/merge request!","title":"Indirect dependencies"},{"location":"reference/documenter/","text":"Documenter module docstring. Documenter \u00b6 Class that contains the object documentation loading mechanisms. __init__ ( self , global_filters ) (special) \u00b6 Show source code 534 535 def __init__ ( self , global_filters ): self . global_filters = [( f , re . compile ( f . lstrip ( \"!\" ))) for f in global_filters ] Initialize self. See help(type(self)) for accurate signature. get_object_documentation ( self , import_string ) \u00b6 Show source code 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 def get_object_documentation ( self , import_string : str ) -> Object : \"\"\" Documenting to see return type. Return: The object with all its children populated. \"\"\" module , obj = import_object ( import_string ) path = module . __name__ if inspect . ismodule ( obj ): root_object = self . get_module_documentation ( obj , path ) elif inspect . isclass ( obj ): path = f \" {path} . {obj.__name__} \" root_object = self . get_class_documentation ( obj , path ) elif inspect . isfunction ( obj ): path = f \" {path} . {obj.__name__} \" root_object = self . get_function_documentation ( obj , path ) else : raise ValueError ( f \" {obj} :{type(obj)} not yet supported\" ) attributes = get_attributes ( module ) root_object . dispatch_attributes ([ a for a in attributes if not self . filter_name_out ( a . name )]) return root_object Documenting to see return type. Returns Type Description Object The object with all its children populated. Object \u00b6 Class to store information about a Python object. the object category (ex: module, function, class, method or attribute) the object path (ex: package.submodule.class.inner_class.method ) the object name (ex: __init__ ) the object docstring the object properties, depending on its category (ex: special, classmethod, etc.) the object signature (soon) Each instance additionally stores references to its children, grouped by category (see Attributes). attributes \u00b6 List of all the object's attributes. children \u00b6 List of all the object's children. classes \u00b6 List of all the object's classes. functions \u00b6 List of all the object's functions. methods \u00b6 List of all the object's methods. modules \u00b6 List of all the object's submodules. parent_path (property, readonly) \u00b6 The parent's path, computed from the current path. __init__ ( self , category , name , path , docstring , properties , signature = None , source = None , file = None ) (special) \u00b6 Show source code 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 def __init__ ( self , category : str , name : str , path : str , docstring : str , properties : List [ str ], signature : Optional [ str ] = None , source : Optional [ str ] = None , file : Optional [ str ] = None , ) -> None : self . category = category self . name = name self . signature = signature or \"\" self . path = path self . docstring = docstring or \"\" self . properties = properties self . parent = None self . source = source or \"\" self . file = file or \"\" self . _path_map = {} self . attributes = [] \"\"\"List of all the object's attributes.\"\"\" self . methods = [] \"\"\"List of all the object's methods.\"\"\" self . functions = [] \"\"\"List of all the object's functions.\"\"\" self . modules = [] \"\"\"List of all the object's submodules.\"\"\" self . classes = [] \"\"\"List of all the object's classes.\"\"\" self . children = [] \"\"\"List of all the object's children.\"\"\" Initialize self. See help(type(self)) for accurate signature. __str__ ( self ) (special) \u00b6 Show source code 391 392 def __str__ ( self ): return self . path Return str(self). add_child ( self , obj ) \u00b6 Show source code 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 def add_child ( self , obj : \"Object\" ) -> None : \"\"\"Add an object as a child of this object.\"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) { CATEGORY_ATTRIBUTE : self . attributes , CATEGORY_METHOD : self . methods , CATEGORY_FUNCTION : self . functions , CATEGORY_MODULE : self . modules , CATEGORY_CLASS : self . classes , } . get ( obj . category ) . append ( obj ) obj . parent = self self . _path_map [ obj . path ] = obj Add an object as a child of this object. add_children ( self , children ) \u00b6 Show source code 416 417 418 419 def add_children ( self , children : List [ \"Object\" ]) -> None : \"\"\"Add a list of objects as children of this object.\"\"\" for child in children : self . add_child ( child ) Add a list of objects as children of this object. render ( self , heading = 1 , ** config ) \u00b6 Show source code 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def render ( self , heading : int = 1 , ** config : Dict [ str , Any ]) -> str : \"\"\" Render this object as Markdown. This is dirty and will be refactored as a Markdown extension soon. Parameters: heading: The initial level of heading to use. config: The rendering configuration dictionary. Returns: The rendered Markdown. \"\"\" lines = [] show_top_object_heading = config . pop ( \"show_top_object_heading\" , True ) show_top_object_full_path = config . pop ( \"show_top_object_full_path\" , False ) if show_top_object_heading : if self . docstring or not config [ \"hide_no_doc\" ] or not self . parent : signature = \"\" toc_signature = \"\" if self . category in ( CATEGORY_FUNCTION , CATEGORY_METHOD ): if self . signature : signature = f \"({render_signature(self.signature)})\" toc_signature = \"()\" object_heading = f \"`:::python {self.path if show_top_object_full_path else self.name} {signature} `\" object_permalink = self . path . replace ( \"__\" , r \"\\_\\_\" ) object_toc = self . name . replace ( \"__\" , r \"\\_\\_\" ) + toc_signature properties = \", \" . join ( self . properties ) if properties : object_heading += f \"*( {properties} )*\" lines . append ( f \"{'#' * heading} {object_heading} {{: # {object_permalink} data-toc-label=' {object_toc} ' }}\" ) if config [ \"add_source_details\" ] and self . source : lines . append ( \"\" ) lines . append ( f '??? note \"Show source code\"' ) lines . append ( f ' ```python linenums=\" {self.source[1]} \"' ) lines . append ( textwrap . indent ( \"\" . join ( self . source [ 0 ]), \" \" )) lines . append ( \" ```\" ) lines . append ( \"\" ) if self . docstring : lines . append ( parse_docstring ( self . docstring , self . signature )) lines . append ( \"\" ) if config [ \"group_by_categories\" ]: lines . append ( self . render_categories ( heading + 1 , ** config ,)) else : for child in sorted ( self . children , key = lambda o : o . name . lower ()): lines . append ( child . render ( heading + 1 , ** config ,)) lines . append ( \"\" ) return \" \\n \" . join ( lines ) Render this object as Markdown. This is dirty and will be refactored as a Markdown extension soon. Parameters Name Type Description heading int The initial level of heading to use. **config Dict[str, Any] The rendering configuration dictionary. Returns Type Description str The rendered Markdown. import_object ( path ) \u00b6 Show source code 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def import_object ( path : str ) -> Tuple [ ModuleType , Any ]: \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through ``importlib.import_module`` and each object is obtainable through the ``getattr`` method. Local objects will not work. Args: path: the dot-separated path of the object. Returns: tuple: the imported module and obtained object. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not {path} \" ) obj_parent_modules = path . split ( \".\" ) objects = [] while True : try : parent_module_path = \".\" . join ( obj_parent_modules ) parent_module = importlib . import_module ( parent_module_path ) break except ImportError : if len ( obj_parent_modules ) == 1 : raise ImportError ( \"No module named ' %s '\" % obj_parent_modules [ 0 ]) objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) current_object = parent_module for obj in objects : current_object = getattr ( current_object , obj ) module = inspect . getmodule ( current_object ) return module , current_object Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. Local objects will not work. Parameters Name Type Description path str the dot-separated path of the object. Returns Type Description Tuple[module, Any] tuple: the imported module and obtained object. parse_docstring ( docstring , signature ) \u00b6 Show source code 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def parse_docstring ( docstring : str , signature ) -> str : \"\"\" Parse a docstring! Note: to try notes. Args: docstring: this is the docstring to parse. Raises: OSError: no it doesn't lol. Returns: markdown: the docstring converted to a nice markdown text. \"\"\" params = {} exceptions = {} returns = \"\" lines = docstring . split ( \" \\n \" ) new_lines = [] i = 0 while i < len ( lines ): if lines [ i ] . lower () in ( \"args:\" , \"arguments:\" , \"params:\" , \"parameters:\" ): j = i + 1 name = None while j < len ( lines ) and lines [ j ] . startswith ( \" \" ): if lines [ j ] . startswith ( \" \" ) and params [ name ]: params [ name ] += \" \" + lines [ j ] . lstrip ( \" \" ) else : name , description = lines [ j ] . lstrip ( \" \" ) . split ( \":\" , 1 ) params [ name ] = description . lstrip ( \" \" ) j += 1 new_lines . append ( \"**Parameters** \\n \" ) new_lines . append ( \"| Name | Type | Description |\" ) new_lines . append ( \"| ---- | ---- | ----------- |\" ) for param_name , param_description in params . items (): param_name , param_default , param_type = get_param_info ( signature , param_name ) # if param_default: # param_default = f\"`{param_default}`\" new_lines . append ( f \"| ` {param_name} ` | ` {param_type} ` | {param_description} |\" ) new_lines . append ( \"\" ) i = j - 1 elif lines [ i ] . lower () in ( \"raise:\" , \"raises:\" , \"except:\" , \"exceptions:\" ): j = i + 1 name = None while j < len ( lines ) and lines [ j ] . startswith ( \" \" ): if lines [ j ] . startswith ( \" \" ) and exceptions [ name ]: exceptions [ name ] += \" \" + lines [ j ] . lstrip ( \" \" ) else : name , description = lines [ j ] . lstrip ( \" \" ) . split ( \":\" , 1 ) exceptions [ name ] = description . lstrip ( \" \" ) j += 1 new_lines . append ( \"**Exceptions** \\n \" ) new_lines . append ( \"| Type | Description |\" ) new_lines . append ( \"| ---- | ----------- |\" ) for exception_name , exception_description in exceptions . items (): new_lines . append ( f \"| ` {exception_name} ` | {exception_description} |\" ) new_lines . append ( \"\" ) i = j - 1 elif lines [ i ] . lower () in ( \"return:\" , \"returns:\" ): j = i + 1 while j < len ( lines ) and lines [ j ] . startswith ( \" \" ): description = lines [ j ] . lstrip ( \" \" ) returns += \" \" + description j += 1 new_lines . append ( \"**Returns** \\n \" ) new_lines . append ( \"| Type | Description |\" ) new_lines . append ( \"| ---- | ----------- |\" ) new_lines . append ( f \"| `{get_return_type(signature)}` | {returns} |\" ) new_lines . append ( \"\" ) i = j - 1 elif lines [ i ] . lower () in ADMONITIONS . keys (): j = i + 1 admonition = [] while j < len ( lines ) and lines [ j ] . startswith ( \" \" ) or lines [ j ] == \"\" : admonition . append ( lines [ j ]) j += 1 new_lines . append ( f \"!!! {ADMONITIONS[lines[i].lower()]}\" ) new_lines . append ( \" \\n \" . join ( admonition )) new_lines . append ( \"\" ) i = j - 1 else : new_lines . append ( lines [ i ]) i += 1 return \" \\n \" . join ( new_lines ) Parse a docstring! Note to try notes. Parameters Name Type Description docstring str this is the docstring to parse. Exceptions Type Description OSError no it doesn't lol. Returns Type Description str markdown: the docstring converted to a nice markdown text.","title":"documenter.py"},{"location":"reference/documenter/#mkdocstrings.documenter.Documenter","text":"Class that contains the object documentation loading mechanisms.","title":"Documenter"},{"location":"reference/documenter/#mkdocstrings.documenter.Documenter.__init__","text":"Show source code 534 535 def __init__ ( self , global_filters ): self . global_filters = [( f , re . compile ( f . lstrip ( \"!\" ))) for f in global_filters ] Initialize self. See help(type(self)) for accurate signature.","title":"__init__()"},{"location":"reference/documenter/#mkdocstrings.documenter.Documenter.get_object_documentation","text":"Show source code 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 def get_object_documentation ( self , import_string : str ) -> Object : \"\"\" Documenting to see return type. Return: The object with all its children populated. \"\"\" module , obj = import_object ( import_string ) path = module . __name__ if inspect . ismodule ( obj ): root_object = self . get_module_documentation ( obj , path ) elif inspect . isclass ( obj ): path = f \" {path} . {obj.__name__} \" root_object = self . get_class_documentation ( obj , path ) elif inspect . isfunction ( obj ): path = f \" {path} . {obj.__name__} \" root_object = self . get_function_documentation ( obj , path ) else : raise ValueError ( f \" {obj} :{type(obj)} not yet supported\" ) attributes = get_attributes ( module ) root_object . dispatch_attributes ([ a for a in attributes if not self . filter_name_out ( a . name )]) return root_object Documenting to see return type. Returns Type Description Object The object with all its children populated.","title":"get_object_documentation()"},{"location":"reference/documenter/#mkdocstrings.documenter.Object","text":"Class to store information about a Python object. the object category (ex: module, function, class, method or attribute) the object path (ex: package.submodule.class.inner_class.method ) the object name (ex: __init__ ) the object docstring the object properties, depending on its category (ex: special, classmethod, etc.) the object signature (soon) Each instance additionally stores references to its children, grouped by category (see Attributes).","title":"Object"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.attributes","text":"List of all the object's attributes.","title":"attributes"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.children","text":"List of all the object's children.","title":"children"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.classes","text":"List of all the object's classes.","title":"classes"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.functions","text":"List of all the object's functions.","title":"functions"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.methods","text":"List of all the object's methods.","title":"methods"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.modules","text":"List of all the object's submodules.","title":"modules"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.parent_path","text":"The parent's path, computed from the current path.","title":"parent_path"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.__init__","text":"Show source code 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 def __init__ ( self , category : str , name : str , path : str , docstring : str , properties : List [ str ], signature : Optional [ str ] = None , source : Optional [ str ] = None , file : Optional [ str ] = None , ) -> None : self . category = category self . name = name self . signature = signature or \"\" self . path = path self . docstring = docstring or \"\" self . properties = properties self . parent = None self . source = source or \"\" self . file = file or \"\" self . _path_map = {} self . attributes = [] \"\"\"List of all the object's attributes.\"\"\" self . methods = [] \"\"\"List of all the object's methods.\"\"\" self . functions = [] \"\"\"List of all the object's functions.\"\"\" self . modules = [] \"\"\"List of all the object's submodules.\"\"\" self . classes = [] \"\"\"List of all the object's classes.\"\"\" self . children = [] \"\"\"List of all the object's children.\"\"\" Initialize self. See help(type(self)) for accurate signature.","title":"__init__()"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.__str__","text":"Show source code 391 392 def __str__ ( self ): return self . path Return str(self).","title":"__str__()"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.add_child","text":"Show source code 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 def add_child ( self , obj : \"Object\" ) -> None : \"\"\"Add an object as a child of this object.\"\"\" if obj . parent_path != self . path : return self . children . append ( obj ) { CATEGORY_ATTRIBUTE : self . attributes , CATEGORY_METHOD : self . methods , CATEGORY_FUNCTION : self . functions , CATEGORY_MODULE : self . modules , CATEGORY_CLASS : self . classes , } . get ( obj . category ) . append ( obj ) obj . parent = self self . _path_map [ obj . path ] = obj Add an object as a child of this object.","title":"add_child()"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.add_children","text":"Show source code 416 417 418 419 def add_children ( self , children : List [ \"Object\" ]) -> None : \"\"\"Add a list of objects as children of this object.\"\"\" for child in children : self . add_child ( child ) Add a list of objects as children of this object.","title":"add_children()"},{"location":"reference/documenter/#mkdocstrings.documenter.Object.render","text":"Show source code 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 def render ( self , heading : int = 1 , ** config : Dict [ str , Any ]) -> str : \"\"\" Render this object as Markdown. This is dirty and will be refactored as a Markdown extension soon. Parameters: heading: The initial level of heading to use. config: The rendering configuration dictionary. Returns: The rendered Markdown. \"\"\" lines = [] show_top_object_heading = config . pop ( \"show_top_object_heading\" , True ) show_top_object_full_path = config . pop ( \"show_top_object_full_path\" , False ) if show_top_object_heading : if self . docstring or not config [ \"hide_no_doc\" ] or not self . parent : signature = \"\" toc_signature = \"\" if self . category in ( CATEGORY_FUNCTION , CATEGORY_METHOD ): if self . signature : signature = f \"({render_signature(self.signature)})\" toc_signature = \"()\" object_heading = f \"`:::python {self.path if show_top_object_full_path else self.name} {signature} `\" object_permalink = self . path . replace ( \"__\" , r \"\\_\\_\" ) object_toc = self . name . replace ( \"__\" , r \"\\_\\_\" ) + toc_signature properties = \", \" . join ( self . properties ) if properties : object_heading += f \"*( {properties} )*\" lines . append ( f \"{'#' * heading} {object_heading} {{: # {object_permalink} data-toc-label=' {object_toc} ' }}\" ) if config [ \"add_source_details\" ] and self . source : lines . append ( \"\" ) lines . append ( f '??? note \"Show source code\"' ) lines . append ( f ' ```python linenums=\" {self.source[1]} \"' ) lines . append ( textwrap . indent ( \"\" . join ( self . source [ 0 ]), \" \" )) lines . append ( \" ```\" ) lines . append ( \"\" ) if self . docstring : lines . append ( parse_docstring ( self . docstring , self . signature )) lines . append ( \"\" ) if config [ \"group_by_categories\" ]: lines . append ( self . render_categories ( heading + 1 , ** config ,)) else : for child in sorted ( self . children , key = lambda o : o . name . lower ()): lines . append ( child . render ( heading + 1 , ** config ,)) lines . append ( \"\" ) return \" \\n \" . join ( lines ) Render this object as Markdown. This is dirty and will be refactored as a Markdown extension soon. Parameters Name Type Description heading int The initial level of heading to use. **config Dict[str, Any] The rendering configuration dictionary. Returns Type Description str The rendered Markdown.","title":"render()"},{"location":"reference/documenter/#mkdocstrings.documenter.import_object","text":"Show source code 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def import_object ( path : str ) -> Tuple [ ModuleType , Any ]: \"\"\" Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through ``importlib.import_module`` and each object is obtainable through the ``getattr`` method. Local objects will not work. Args: path: the dot-separated path of the object. Returns: tuple: the imported module and obtained object. \"\"\" if not path : raise ValueError ( f \"path must be a valid Python path, not {path} \" ) obj_parent_modules = path . split ( \".\" ) objects = [] while True : try : parent_module_path = \".\" . join ( obj_parent_modules ) parent_module = importlib . import_module ( parent_module_path ) break except ImportError : if len ( obj_parent_modules ) == 1 : raise ImportError ( \"No module named ' %s '\" % obj_parent_modules [ 0 ]) objects . insert ( 0 , obj_parent_modules . pop ( - 1 )) current_object = parent_module for obj in objects : current_object = getattr ( current_object , obj ) module = inspect . getmodule ( current_object ) return module , current_object Transform a path into an actual Python object. The path can be arbitrary long. You can pass the path to a package, a module, a class, a function or a global variable, as deep as you want, as long as the deepest module is importable through importlib.import_module and each object is obtainable through the getattr method. Local objects will not work. Parameters Name Type Description path str the dot-separated path of the object. Returns Type Description Tuple[module, Any] tuple: the imported module and obtained object.","title":"import_object()"},{"location":"reference/documenter/#mkdocstrings.documenter.parse_docstring","text":"Show source code 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 def parse_docstring ( docstring : str , signature ) -> str : \"\"\" Parse a docstring! Note: to try notes. Args: docstring: this is the docstring to parse. Raises: OSError: no it doesn't lol. Returns: markdown: the docstring converted to a nice markdown text. \"\"\" params = {} exceptions = {} returns = \"\" lines = docstring . split ( \" \\n \" ) new_lines = [] i = 0 while i < len ( lines ): if lines [ i ] . lower () in ( \"args:\" , \"arguments:\" , \"params:\" , \"parameters:\" ): j = i + 1 name = None while j < len ( lines ) and lines [ j ] . startswith ( \" \" ): if lines [ j ] . startswith ( \" \" ) and params [ name ]: params [ name ] += \" \" + lines [ j ] . lstrip ( \" \" ) else : name , description = lines [ j ] . lstrip ( \" \" ) . split ( \":\" , 1 ) params [ name ] = description . lstrip ( \" \" ) j += 1 new_lines . append ( \"**Parameters** \\n \" ) new_lines . append ( \"| Name | Type | Description |\" ) new_lines . append ( \"| ---- | ---- | ----------- |\" ) for param_name , param_description in params . items (): param_name , param_default , param_type = get_param_info ( signature , param_name ) # if param_default: # param_default = f\"`{param_default}`\" new_lines . append ( f \"| ` {param_name} ` | ` {param_type} ` | {param_description} |\" ) new_lines . append ( \"\" ) i = j - 1 elif lines [ i ] . lower () in ( \"raise:\" , \"raises:\" , \"except:\" , \"exceptions:\" ): j = i + 1 name = None while j < len ( lines ) and lines [ j ] . startswith ( \" \" ): if lines [ j ] . startswith ( \" \" ) and exceptions [ name ]: exceptions [ name ] += \" \" + lines [ j ] . lstrip ( \" \" ) else : name , description = lines [ j ] . lstrip ( \" \" ) . split ( \":\" , 1 ) exceptions [ name ] = description . lstrip ( \" \" ) j += 1 new_lines . append ( \"**Exceptions** \\n \" ) new_lines . append ( \"| Type | Description |\" ) new_lines . append ( \"| ---- | ----------- |\" ) for exception_name , exception_description in exceptions . items (): new_lines . append ( f \"| ` {exception_name} ` | {exception_description} |\" ) new_lines . append ( \"\" ) i = j - 1 elif lines [ i ] . lower () in ( \"return:\" , \"returns:\" ): j = i + 1 while j < len ( lines ) and lines [ j ] . startswith ( \" \" ): description = lines [ j ] . lstrip ( \" \" ) returns += \" \" + description j += 1 new_lines . append ( \"**Returns** \\n \" ) new_lines . append ( \"| Type | Description |\" ) new_lines . append ( \"| ---- | ----------- |\" ) new_lines . append ( f \"| `{get_return_type(signature)}` | {returns} |\" ) new_lines . append ( \"\" ) i = j - 1 elif lines [ i ] . lower () in ADMONITIONS . keys (): j = i + 1 admonition = [] while j < len ( lines ) and lines [ j ] . startswith ( \" \" ) or lines [ j ] == \"\" : admonition . append ( lines [ j ]) j += 1 new_lines . append ( f \"!!! {ADMONITIONS[lines[i].lower()]}\" ) new_lines . append ( \" \\n \" . join ( admonition )) new_lines . append ( \"\" ) i = j - 1 else : new_lines . append ( lines [ i ]) i += 1 return \" \\n \" . join ( new_lines ) Parse a docstring! Note to try notes. Parameters Name Type Description docstring str this is the docstring to parse. Exceptions Type Description OSError no it doesn't lol. Returns Type Description str markdown: the docstring converted to a nice markdown text.","title":"parse_docstring()"},{"location":"reference/plugin/","text":"Plugin module docstring. MkdocstringsPlugin \u00b6 The mkdocstrings plugin to use in your mkdocs configuration file. __init__ ( self , * args , ** kwargs ) (special) \u00b6 Show source code 47 48 49 50 51 52 53 def __init__ ( self , * args , ** kwargs ) -> None : super ( MkdocstringsPlugin , self ) . __init__ () self . hide_no_doc = True self . documenter = None self . objects = {} self . pages_with_docstrings = [] self . references = [] Initialize self. See help(type(self)) for accurate signature. on_config ( self , config , ** kwargs ) \u00b6 Show source code 55 56 57 58 def on_config ( self , config , ** kwargs ): \"\"\"Initializes a [Documenter][mkdocstrings.documenter.Documenter].\"\"\" self . documenter = Documenter ( self . config [ \"global_filters\" ]) return config Initializes a Documenter .","title":"plugin.py"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin","text":"The mkdocstrings plugin to use in your mkdocs configuration file.","title":"MkdocstringsPlugin"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.__init__","text":"Show source code 47 48 49 50 51 52 53 def __init__ ( self , * args , ** kwargs ) -> None : super ( MkdocstringsPlugin , self ) . __init__ () self . hide_no_doc = True self . documenter = None self . objects = {} self . pages_with_docstrings = [] self . references = [] Initialize self. See help(type(self)) for accurate signature.","title":"__init__()"},{"location":"reference/plugin/#mkdocstrings.plugin.MkdocstringsPlugin.on_config","text":"Show source code 55 56 57 58 def on_config ( self , config , ** kwargs ): \"\"\"Initializes a [Documenter][mkdocstrings.documenter.Documenter].\"\"\" self . documenter = Documenter ( self . config [ \"global_filters\" ]) return config Initializes a Documenter .","title":"on_config()"}]}